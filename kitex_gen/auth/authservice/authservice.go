// Code generated by Kitex v0.14.1. DO NOT EDIT.

package authservice

import (
	"context"
	"errors"
	auth "github.com/123508/xservergo/kitex_gen/auth"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"CreatePermission": kitex.NewMethodInfo(
		createPermissionHandler,
		newCreatePermissionArgs,
		newCreatePermissionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdatePermission": kitex.NewMethodInfo(
		updatePermissionHandler,
		newUpdatePermissionArgs,
		newUpdatePermissionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeletePermission": kitex.NewMethodInfo(
		deletePermissionHandler,
		newDeletePermissionArgs,
		newDeletePermissionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetPermission": kitex.NewMethodInfo(
		getPermissionHandler,
		newGetPermissionArgs,
		newGetPermissionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateRole": kitex.NewMethodInfo(
		createRoleHandler,
		newCreateRoleArgs,
		newCreateRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateRole": kitex.NewMethodInfo(
		updateRoleHandler,
		newUpdateRoleArgs,
		newUpdateRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteRole": kitex.NewMethodInfo(
		deleteRoleHandler,
		newDeleteRoleArgs,
		newDeleteRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetRole": kitex.NewMethodInfo(
		getRoleHandler,
		newGetRoleArgs,
		newGetRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GrantPermissionToRole": kitex.NewMethodInfo(
		grantPermissionToRoleHandler,
		newGrantPermissionToRoleArgs,
		newGrantPermissionToRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RevokePermissionFromRole": kitex.NewMethodInfo(
		revokePermissionFromRoleHandler,
		newRevokePermissionFromRoleArgs,
		newRevokePermissionFromRoleResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetRolePermissions": kitex.NewMethodInfo(
		getRolePermissionsHandler,
		newGetRolePermissionsArgs,
		newGetRolePermissionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AssignRoleToUser": kitex.NewMethodInfo(
		assignRoleToUserHandler,
		newAssignRoleToUserArgs,
		newAssignRoleToUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RemoveRoleFromUser": kitex.NewMethodInfo(
		removeRoleFromUserHandler,
		newRemoveRoleFromUserArgs,
		newRemoveRoleFromUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserRoles": kitex.NewMethodInfo(
		getUserRolesHandler,
		newGetUserRolesArgs,
		newGetUserRolesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateUserGroup": kitex.NewMethodInfo(
		createUserGroupHandler,
		newCreateUserGroupArgs,
		newCreateUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUserGroup": kitex.NewMethodInfo(
		updateUserGroupHandler,
		newUpdateUserGroupArgs,
		newUpdateUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUserGroup": kitex.NewMethodInfo(
		deleteUserGroupHandler,
		newDeleteUserGroupArgs,
		newDeleteUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserGroup": kitex.NewMethodInfo(
		getUserGroupHandler,
		newGetUserGroupArgs,
		newGetUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserGroupMembers": kitex.NewMethodInfo(
		getUserGroupMembersHandler,
		newGetUserGroupMembersArgs,
		newGetUserGroupMembersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AssignRoleToUserGroup": kitex.NewMethodInfo(
		assignRoleToUserGroupHandler,
		newAssignRoleToUserGroupArgs,
		newAssignRoleToUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RemoveRoleFromUserGroup": kitex.NewMethodInfo(
		removeRoleFromUserGroupHandler,
		newRemoveRoleFromUserGroupArgs,
		newRemoveRoleFromUserGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserGroupPermissions": kitex.NewMethodInfo(
		getUserGroupPermissionsHandler,
		newGetUserGroupPermissionsArgs,
		newGetUserGroupPermissionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AssignUserToGroup": kitex.NewMethodInfo(
		assignUserToGroupHandler,
		newAssignUserToGroupArgs,
		newAssignUserToGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RemoveUserFromGroup": kitex.NewMethodInfo(
		removeUserFromGroupHandler,
		newRemoveUserFromGroupArgs,
		newRemoveUserFromGroupResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserGroups": kitex.NewMethodInfo(
		getUserGroupsHandler,
		newGetUserGroupsArgs,
		newGetUserGroupsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserPermissions": kitex.NewMethodInfo(
		getUserPermissionsHandler,
		newGetUserPermissionsArgs,
		newGetUserPermissionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"HasPermission": kitex.NewMethodInfo(
		hasPermissionHandler,
		newHasPermissionArgs,
		newHasPermissionResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CanAccess": kitex.NewMethodInfo(
		canAccessHandler,
		newCanAccessArgs,
		newCanAccessResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListRoles": kitex.NewMethodInfo(
		listRolesHandler,
		newListRolesArgs,
		newListRolesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListUserGroups": kitex.NewMethodInfo(
		listUserGroupsHandler,
		newListUserGroupsArgs,
		newListUserGroupsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListPermissions": kitex.NewMethodInfo(
		listPermissionsHandler,
		newListPermissionsArgs,
		newListPermissionsResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"IssueToken": kitex.NewMethodInfo(
		issueTokenHandler,
		newIssueTokenArgs,
		newIssueTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RefreshToken": kitex.NewMethodInfo(
		refreshTokenHandler,
		newRefreshTokenArgs,
		newRefreshTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyToken": kitex.NewMethodInfo(
		verifyTokenHandler,
		newVerifyTokenArgs,
		newVerifyTokenResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	authServiceServiceInfo                = NewServiceInfo()
	authServiceServiceInfoForClient       = NewServiceInfoForClient()
	authServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return authServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return authServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return authServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "AuthService"
	handlerType := (*auth.AuthService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "auth",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func createPermissionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.CreatePermissionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).CreatePermission(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreatePermissionArgs:
		success, err := handler.(auth.AuthService).CreatePermission(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreatePermissionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreatePermissionArgs() interface{} {
	return &CreatePermissionArgs{}
}

func newCreatePermissionResult() interface{} {
	return &CreatePermissionResult{}
}

type CreatePermissionArgs struct {
	Req *auth.CreatePermissionReq
}

func (p *CreatePermissionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreatePermissionArgs) Unmarshal(in []byte) error {
	msg := new(auth.CreatePermissionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreatePermissionArgs_Req_DEFAULT *auth.CreatePermissionReq

func (p *CreatePermissionArgs) GetReq() *auth.CreatePermissionReq {
	if !p.IsSetReq() {
		return CreatePermissionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreatePermissionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreatePermissionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreatePermissionResult struct {
	Success *auth.Permission
}

var CreatePermissionResult_Success_DEFAULT *auth.Permission

func (p *CreatePermissionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreatePermissionResult) Unmarshal(in []byte) error {
	msg := new(auth.Permission)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreatePermissionResult) GetSuccess() *auth.Permission {
	if !p.IsSetSuccess() {
		return CreatePermissionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreatePermissionResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Permission)
}

func (p *CreatePermissionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreatePermissionResult) GetResult() interface{} {
	return p.Success
}

func updatePermissionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.UpdatePermissionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).UpdatePermission(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdatePermissionArgs:
		success, err := handler.(auth.AuthService).UpdatePermission(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdatePermissionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdatePermissionArgs() interface{} {
	return &UpdatePermissionArgs{}
}

func newUpdatePermissionResult() interface{} {
	return &UpdatePermissionResult{}
}

type UpdatePermissionArgs struct {
	Req *auth.UpdatePermissionReq
}

func (p *UpdatePermissionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdatePermissionArgs) Unmarshal(in []byte) error {
	msg := new(auth.UpdatePermissionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdatePermissionArgs_Req_DEFAULT *auth.UpdatePermissionReq

func (p *UpdatePermissionArgs) GetReq() *auth.UpdatePermissionReq {
	if !p.IsSetReq() {
		return UpdatePermissionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdatePermissionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdatePermissionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdatePermissionResult struct {
	Success *auth.Permission
}

var UpdatePermissionResult_Success_DEFAULT *auth.Permission

func (p *UpdatePermissionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdatePermissionResult) Unmarshal(in []byte) error {
	msg := new(auth.Permission)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdatePermissionResult) GetSuccess() *auth.Permission {
	if !p.IsSetSuccess() {
		return UpdatePermissionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdatePermissionResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Permission)
}

func (p *UpdatePermissionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdatePermissionResult) GetResult() interface{} {
	return p.Success
}

func deletePermissionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.DeletePermissionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).DeletePermission(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeletePermissionArgs:
		success, err := handler.(auth.AuthService).DeletePermission(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeletePermissionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeletePermissionArgs() interface{} {
	return &DeletePermissionArgs{}
}

func newDeletePermissionResult() interface{} {
	return &DeletePermissionResult{}
}

type DeletePermissionArgs struct {
	Req *auth.DeletePermissionReq
}

func (p *DeletePermissionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeletePermissionArgs) Unmarshal(in []byte) error {
	msg := new(auth.DeletePermissionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeletePermissionArgs_Req_DEFAULT *auth.DeletePermissionReq

func (p *DeletePermissionArgs) GetReq() *auth.DeletePermissionReq {
	if !p.IsSetReq() {
		return DeletePermissionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeletePermissionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeletePermissionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeletePermissionResult struct {
	Success *auth.OperationResult
}

var DeletePermissionResult_Success_DEFAULT *auth.OperationResult

func (p *DeletePermissionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeletePermissionResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeletePermissionResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return DeletePermissionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeletePermissionResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *DeletePermissionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeletePermissionResult) GetResult() interface{} {
	return p.Success
}

func getPermissionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetPermissionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetPermission(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetPermissionArgs:
		success, err := handler.(auth.AuthService).GetPermission(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPermissionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetPermissionArgs() interface{} {
	return &GetPermissionArgs{}
}

func newGetPermissionResult() interface{} {
	return &GetPermissionResult{}
}

type GetPermissionArgs struct {
	Req *auth.GetPermissionReq
}

func (p *GetPermissionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPermissionArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetPermissionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPermissionArgs_Req_DEFAULT *auth.GetPermissionReq

func (p *GetPermissionArgs) GetReq() *auth.GetPermissionReq {
	if !p.IsSetReq() {
		return GetPermissionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPermissionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPermissionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPermissionResult struct {
	Success *auth.Permission
}

var GetPermissionResult_Success_DEFAULT *auth.Permission

func (p *GetPermissionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPermissionResult) Unmarshal(in []byte) error {
	msg := new(auth.Permission)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPermissionResult) GetSuccess() *auth.Permission {
	if !p.IsSetSuccess() {
		return GetPermissionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPermissionResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Permission)
}

func (p *GetPermissionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPermissionResult) GetResult() interface{} {
	return p.Success
}

func createRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.CreateRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).CreateRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateRoleArgs:
		success, err := handler.(auth.AuthService).CreateRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateRoleArgs() interface{} {
	return &CreateRoleArgs{}
}

func newCreateRoleResult() interface{} {
	return &CreateRoleResult{}
}

type CreateRoleArgs struct {
	Req *auth.CreateRoleReq
}

func (p *CreateRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.CreateRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateRoleArgs_Req_DEFAULT *auth.CreateRoleReq

func (p *CreateRoleArgs) GetReq() *auth.CreateRoleReq {
	if !p.IsSetReq() {
		return CreateRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateRoleResult struct {
	Success *auth.Role
}

var CreateRoleResult_Success_DEFAULT *auth.Role

func (p *CreateRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.Role)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateRoleResult) GetSuccess() *auth.Role {
	if !p.IsSetSuccess() {
		return CreateRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Role)
}

func (p *CreateRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateRoleResult) GetResult() interface{} {
	return p.Success
}

func updateRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.UpdateRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).UpdateRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateRoleArgs:
		success, err := handler.(auth.AuthService).UpdateRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateRoleArgs() interface{} {
	return &UpdateRoleArgs{}
}

func newUpdateRoleResult() interface{} {
	return &UpdateRoleResult{}
}

type UpdateRoleArgs struct {
	Req *auth.UpdateRoleReq
}

func (p *UpdateRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.UpdateRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateRoleArgs_Req_DEFAULT *auth.UpdateRoleReq

func (p *UpdateRoleArgs) GetReq() *auth.UpdateRoleReq {
	if !p.IsSetReq() {
		return UpdateRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateRoleResult struct {
	Success *auth.Role
}

var UpdateRoleResult_Success_DEFAULT *auth.Role

func (p *UpdateRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.Role)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateRoleResult) GetSuccess() *auth.Role {
	if !p.IsSetSuccess() {
		return UpdateRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Role)
}

func (p *UpdateRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateRoleResult) GetResult() interface{} {
	return p.Success
}

func deleteRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.DeleteRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).DeleteRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteRoleArgs:
		success, err := handler.(auth.AuthService).DeleteRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteRoleArgs() interface{} {
	return &DeleteRoleArgs{}
}

func newDeleteRoleResult() interface{} {
	return &DeleteRoleResult{}
}

type DeleteRoleArgs struct {
	Req *auth.DeleteRoleReq
}

func (p *DeleteRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.DeleteRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteRoleArgs_Req_DEFAULT *auth.DeleteRoleReq

func (p *DeleteRoleArgs) GetReq() *auth.DeleteRoleReq {
	if !p.IsSetReq() {
		return DeleteRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteRoleResult struct {
	Success *auth.OperationResult
}

var DeleteRoleResult_Success_DEFAULT *auth.OperationResult

func (p *DeleteRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteRoleResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return DeleteRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *DeleteRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteRoleResult) GetResult() interface{} {
	return p.Success
}

func getRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetRoleArgs:
		success, err := handler.(auth.AuthService).GetRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetRoleArgs() interface{} {
	return &GetRoleArgs{}
}

func newGetRoleResult() interface{} {
	return &GetRoleResult{}
}

type GetRoleArgs struct {
	Req *auth.GetRoleReq
}

func (p *GetRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRoleArgs_Req_DEFAULT *auth.GetRoleReq

func (p *GetRoleArgs) GetReq() *auth.GetRoleReq {
	if !p.IsSetReq() {
		return GetRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetRoleResult struct {
	Success *auth.Role
}

var GetRoleResult_Success_DEFAULT *auth.Role

func (p *GetRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.Role)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRoleResult) GetSuccess() *auth.Role {
	if !p.IsSetSuccess() {
		return GetRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.Role)
}

func (p *GetRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRoleResult) GetResult() interface{} {
	return p.Success
}

func grantPermissionToRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GrantPermissionToRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GrantPermissionToRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GrantPermissionToRoleArgs:
		success, err := handler.(auth.AuthService).GrantPermissionToRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GrantPermissionToRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGrantPermissionToRoleArgs() interface{} {
	return &GrantPermissionToRoleArgs{}
}

func newGrantPermissionToRoleResult() interface{} {
	return &GrantPermissionToRoleResult{}
}

type GrantPermissionToRoleArgs struct {
	Req *auth.GrantPermissionToRoleReq
}

func (p *GrantPermissionToRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GrantPermissionToRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.GrantPermissionToRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GrantPermissionToRoleArgs_Req_DEFAULT *auth.GrantPermissionToRoleReq

func (p *GrantPermissionToRoleArgs) GetReq() *auth.GrantPermissionToRoleReq {
	if !p.IsSetReq() {
		return GrantPermissionToRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GrantPermissionToRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GrantPermissionToRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GrantPermissionToRoleResult struct {
	Success *auth.OperationResult
}

var GrantPermissionToRoleResult_Success_DEFAULT *auth.OperationResult

func (p *GrantPermissionToRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GrantPermissionToRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GrantPermissionToRoleResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return GrantPermissionToRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GrantPermissionToRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *GrantPermissionToRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GrantPermissionToRoleResult) GetResult() interface{} {
	return p.Success
}

func revokePermissionFromRoleHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.RevokePermissionFromRoleReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).RevokePermissionFromRole(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RevokePermissionFromRoleArgs:
		success, err := handler.(auth.AuthService).RevokePermissionFromRole(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RevokePermissionFromRoleResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRevokePermissionFromRoleArgs() interface{} {
	return &RevokePermissionFromRoleArgs{}
}

func newRevokePermissionFromRoleResult() interface{} {
	return &RevokePermissionFromRoleResult{}
}

type RevokePermissionFromRoleArgs struct {
	Req *auth.RevokePermissionFromRoleReq
}

func (p *RevokePermissionFromRoleArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RevokePermissionFromRoleArgs) Unmarshal(in []byte) error {
	msg := new(auth.RevokePermissionFromRoleReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RevokePermissionFromRoleArgs_Req_DEFAULT *auth.RevokePermissionFromRoleReq

func (p *RevokePermissionFromRoleArgs) GetReq() *auth.RevokePermissionFromRoleReq {
	if !p.IsSetReq() {
		return RevokePermissionFromRoleArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RevokePermissionFromRoleArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RevokePermissionFromRoleArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RevokePermissionFromRoleResult struct {
	Success *auth.OperationResult
}

var RevokePermissionFromRoleResult_Success_DEFAULT *auth.OperationResult

func (p *RevokePermissionFromRoleResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RevokePermissionFromRoleResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RevokePermissionFromRoleResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return RevokePermissionFromRoleResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RevokePermissionFromRoleResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *RevokePermissionFromRoleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RevokePermissionFromRoleResult) GetResult() interface{} {
	return p.Success
}

func getRolePermissionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetRolePermissionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetRolePermissions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetRolePermissionsArgs:
		success, err := handler.(auth.AuthService).GetRolePermissions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRolePermissionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetRolePermissionsArgs() interface{} {
	return &GetRolePermissionsArgs{}
}

func newGetRolePermissionsResult() interface{} {
	return &GetRolePermissionsResult{}
}

type GetRolePermissionsArgs struct {
	Req *auth.GetRolePermissionsReq
}

func (p *GetRolePermissionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetRolePermissionsArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetRolePermissionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRolePermissionsArgs_Req_DEFAULT *auth.GetRolePermissionsReq

func (p *GetRolePermissionsArgs) GetReq() *auth.GetRolePermissionsReq {
	if !p.IsSetReq() {
		return GetRolePermissionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRolePermissionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetRolePermissionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetRolePermissionsResult struct {
	Success *auth.GetRolePermissionsResp
}

var GetRolePermissionsResult_Success_DEFAULT *auth.GetRolePermissionsResp

func (p *GetRolePermissionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetRolePermissionsResult) Unmarshal(in []byte) error {
	msg := new(auth.GetRolePermissionsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRolePermissionsResult) GetSuccess() *auth.GetRolePermissionsResp {
	if !p.IsSetSuccess() {
		return GetRolePermissionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRolePermissionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetRolePermissionsResp)
}

func (p *GetRolePermissionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRolePermissionsResult) GetResult() interface{} {
	return p.Success
}

func assignRoleToUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.AssignRoleToUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).AssignRoleToUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AssignRoleToUserArgs:
		success, err := handler.(auth.AuthService).AssignRoleToUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AssignRoleToUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAssignRoleToUserArgs() interface{} {
	return &AssignRoleToUserArgs{}
}

func newAssignRoleToUserResult() interface{} {
	return &AssignRoleToUserResult{}
}

type AssignRoleToUserArgs struct {
	Req *auth.AssignRoleToUserReq
}

func (p *AssignRoleToUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AssignRoleToUserArgs) Unmarshal(in []byte) error {
	msg := new(auth.AssignRoleToUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AssignRoleToUserArgs_Req_DEFAULT *auth.AssignRoleToUserReq

func (p *AssignRoleToUserArgs) GetReq() *auth.AssignRoleToUserReq {
	if !p.IsSetReq() {
		return AssignRoleToUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AssignRoleToUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AssignRoleToUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AssignRoleToUserResult struct {
	Success *auth.OperationResult
}

var AssignRoleToUserResult_Success_DEFAULT *auth.OperationResult

func (p *AssignRoleToUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AssignRoleToUserResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AssignRoleToUserResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return AssignRoleToUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AssignRoleToUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *AssignRoleToUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AssignRoleToUserResult) GetResult() interface{} {
	return p.Success
}

func removeRoleFromUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.RemoveRoleFromUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).RemoveRoleFromUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RemoveRoleFromUserArgs:
		success, err := handler.(auth.AuthService).RemoveRoleFromUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RemoveRoleFromUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRemoveRoleFromUserArgs() interface{} {
	return &RemoveRoleFromUserArgs{}
}

func newRemoveRoleFromUserResult() interface{} {
	return &RemoveRoleFromUserResult{}
}

type RemoveRoleFromUserArgs struct {
	Req *auth.RemoveRoleFromUserReq
}

func (p *RemoveRoleFromUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RemoveRoleFromUserArgs) Unmarshal(in []byte) error {
	msg := new(auth.RemoveRoleFromUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RemoveRoleFromUserArgs_Req_DEFAULT *auth.RemoveRoleFromUserReq

func (p *RemoveRoleFromUserArgs) GetReq() *auth.RemoveRoleFromUserReq {
	if !p.IsSetReq() {
		return RemoveRoleFromUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RemoveRoleFromUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RemoveRoleFromUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RemoveRoleFromUserResult struct {
	Success *auth.OperationResult
}

var RemoveRoleFromUserResult_Success_DEFAULT *auth.OperationResult

func (p *RemoveRoleFromUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RemoveRoleFromUserResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RemoveRoleFromUserResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return RemoveRoleFromUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RemoveRoleFromUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *RemoveRoleFromUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoveRoleFromUserResult) GetResult() interface{} {
	return p.Success
}

func getUserRolesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserRolesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserRoles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserRolesArgs:
		success, err := handler.(auth.AuthService).GetUserRoles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserRolesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserRolesArgs() interface{} {
	return &GetUserRolesArgs{}
}

func newGetUserRolesResult() interface{} {
	return &GetUserRolesResult{}
}

type GetUserRolesArgs struct {
	Req *auth.GetUserRolesReq
}

func (p *GetUserRolesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserRolesArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserRolesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserRolesArgs_Req_DEFAULT *auth.GetUserRolesReq

func (p *GetUserRolesArgs) GetReq() *auth.GetUserRolesReq {
	if !p.IsSetReq() {
		return GetUserRolesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserRolesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserRolesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserRolesResult struct {
	Success *auth.GetUserRolesResp
}

var GetUserRolesResult_Success_DEFAULT *auth.GetUserRolesResp

func (p *GetUserRolesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserRolesResult) Unmarshal(in []byte) error {
	msg := new(auth.GetUserRolesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserRolesResult) GetSuccess() *auth.GetUserRolesResp {
	if !p.IsSetSuccess() {
		return GetUserRolesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserRolesResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetUserRolesResp)
}

func (p *GetUserRolesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserRolesResult) GetResult() interface{} {
	return p.Success
}

func createUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.CreateUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).CreateUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateUserGroupArgs:
		success, err := handler.(auth.AuthService).CreateUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateUserGroupArgs() interface{} {
	return &CreateUserGroupArgs{}
}

func newCreateUserGroupResult() interface{} {
	return &CreateUserGroupResult{}
}

type CreateUserGroupArgs struct {
	Req *auth.CreateUserGroupReq
}

func (p *CreateUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.CreateUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateUserGroupArgs_Req_DEFAULT *auth.CreateUserGroupReq

func (p *CreateUserGroupArgs) GetReq() *auth.CreateUserGroupReq {
	if !p.IsSetReq() {
		return CreateUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateUserGroupResult struct {
	Success *auth.UserGroup
}

var CreateUserGroupResult_Success_DEFAULT *auth.UserGroup

func (p *CreateUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.UserGroup)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateUserGroupResult) GetSuccess() *auth.UserGroup {
	if !p.IsSetSuccess() {
		return CreateUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.UserGroup)
}

func (p *CreateUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateUserGroupResult) GetResult() interface{} {
	return p.Success
}

func updateUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.UpdateUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).UpdateUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserGroupArgs:
		success, err := handler.(auth.AuthService).UpdateUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserGroupArgs() interface{} {
	return &UpdateUserGroupArgs{}
}

func newUpdateUserGroupResult() interface{} {
	return &UpdateUserGroupResult{}
}

type UpdateUserGroupArgs struct {
	Req *auth.UpdateUserGroupReq
}

func (p *UpdateUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.UpdateUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserGroupArgs_Req_DEFAULT *auth.UpdateUserGroupReq

func (p *UpdateUserGroupArgs) GetReq() *auth.UpdateUserGroupReq {
	if !p.IsSetReq() {
		return UpdateUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserGroupResult struct {
	Success *auth.UserGroup
}

var UpdateUserGroupResult_Success_DEFAULT *auth.UserGroup

func (p *UpdateUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.UserGroup)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserGroupResult) GetSuccess() *auth.UserGroup {
	if !p.IsSetSuccess() {
		return UpdateUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.UserGroup)
}

func (p *UpdateUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserGroupResult) GetResult() interface{} {
	return p.Success
}

func deleteUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.DeleteUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).DeleteUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUserGroupArgs:
		success, err := handler.(auth.AuthService).DeleteUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUserGroupArgs() interface{} {
	return &DeleteUserGroupArgs{}
}

func newDeleteUserGroupResult() interface{} {
	return &DeleteUserGroupResult{}
}

type DeleteUserGroupArgs struct {
	Req *auth.DeleteUserGroupReq
}

func (p *DeleteUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.DeleteUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUserGroupArgs_Req_DEFAULT *auth.DeleteUserGroupReq

func (p *DeleteUserGroupArgs) GetReq() *auth.DeleteUserGroupReq {
	if !p.IsSetReq() {
		return DeleteUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUserGroupResult struct {
	Success *auth.OperationResult
}

var DeleteUserGroupResult_Success_DEFAULT *auth.OperationResult

func (p *DeleteUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUserGroupResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return DeleteUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *DeleteUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUserGroupResult) GetResult() interface{} {
	return p.Success
}

func getUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserGroupArgs:
		success, err := handler.(auth.AuthService).GetUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserGroupArgs() interface{} {
	return &GetUserGroupArgs{}
}

func newGetUserGroupResult() interface{} {
	return &GetUserGroupResult{}
}

type GetUserGroupArgs struct {
	Req *auth.GetUserGroupReq
}

func (p *GetUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserGroupArgs_Req_DEFAULT *auth.GetUserGroupReq

func (p *GetUserGroupArgs) GetReq() *auth.GetUserGroupReq {
	if !p.IsSetReq() {
		return GetUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserGroupResult struct {
	Success *auth.UserGroup
}

var GetUserGroupResult_Success_DEFAULT *auth.UserGroup

func (p *GetUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.UserGroup)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserGroupResult) GetSuccess() *auth.UserGroup {
	if !p.IsSetSuccess() {
		return GetUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.UserGroup)
}

func (p *GetUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserGroupResult) GetResult() interface{} {
	return p.Success
}

func getUserGroupMembersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserGroupMembersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserGroupMembers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserGroupMembersArgs:
		success, err := handler.(auth.AuthService).GetUserGroupMembers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserGroupMembersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserGroupMembersArgs() interface{} {
	return &GetUserGroupMembersArgs{}
}

func newGetUserGroupMembersResult() interface{} {
	return &GetUserGroupMembersResult{}
}

type GetUserGroupMembersArgs struct {
	Req *auth.GetUserGroupMembersReq
}

func (p *GetUserGroupMembersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserGroupMembersArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupMembersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserGroupMembersArgs_Req_DEFAULT *auth.GetUserGroupMembersReq

func (p *GetUserGroupMembersArgs) GetReq() *auth.GetUserGroupMembersReq {
	if !p.IsSetReq() {
		return GetUserGroupMembersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserGroupMembersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserGroupMembersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserGroupMembersResult struct {
	Success *auth.GetUserGroupMembersResp
}

var GetUserGroupMembersResult_Success_DEFAULT *auth.GetUserGroupMembersResp

func (p *GetUserGroupMembersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserGroupMembersResult) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupMembersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserGroupMembersResult) GetSuccess() *auth.GetUserGroupMembersResp {
	if !p.IsSetSuccess() {
		return GetUserGroupMembersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserGroupMembersResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetUserGroupMembersResp)
}

func (p *GetUserGroupMembersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserGroupMembersResult) GetResult() interface{} {
	return p.Success
}

func assignRoleToUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.AssignRoleToUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).AssignRoleToUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AssignRoleToUserGroupArgs:
		success, err := handler.(auth.AuthService).AssignRoleToUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AssignRoleToUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAssignRoleToUserGroupArgs() interface{} {
	return &AssignRoleToUserGroupArgs{}
}

func newAssignRoleToUserGroupResult() interface{} {
	return &AssignRoleToUserGroupResult{}
}

type AssignRoleToUserGroupArgs struct {
	Req *auth.AssignRoleToUserGroupReq
}

func (p *AssignRoleToUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AssignRoleToUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.AssignRoleToUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AssignRoleToUserGroupArgs_Req_DEFAULT *auth.AssignRoleToUserGroupReq

func (p *AssignRoleToUserGroupArgs) GetReq() *auth.AssignRoleToUserGroupReq {
	if !p.IsSetReq() {
		return AssignRoleToUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AssignRoleToUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AssignRoleToUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AssignRoleToUserGroupResult struct {
	Success *auth.OperationResult
}

var AssignRoleToUserGroupResult_Success_DEFAULT *auth.OperationResult

func (p *AssignRoleToUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AssignRoleToUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AssignRoleToUserGroupResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return AssignRoleToUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AssignRoleToUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *AssignRoleToUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AssignRoleToUserGroupResult) GetResult() interface{} {
	return p.Success
}

func removeRoleFromUserGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.RemoveRoleFromUserGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).RemoveRoleFromUserGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RemoveRoleFromUserGroupArgs:
		success, err := handler.(auth.AuthService).RemoveRoleFromUserGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RemoveRoleFromUserGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRemoveRoleFromUserGroupArgs() interface{} {
	return &RemoveRoleFromUserGroupArgs{}
}

func newRemoveRoleFromUserGroupResult() interface{} {
	return &RemoveRoleFromUserGroupResult{}
}

type RemoveRoleFromUserGroupArgs struct {
	Req *auth.RemoveRoleFromUserGroupReq
}

func (p *RemoveRoleFromUserGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RemoveRoleFromUserGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.RemoveRoleFromUserGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RemoveRoleFromUserGroupArgs_Req_DEFAULT *auth.RemoveRoleFromUserGroupReq

func (p *RemoveRoleFromUserGroupArgs) GetReq() *auth.RemoveRoleFromUserGroupReq {
	if !p.IsSetReq() {
		return RemoveRoleFromUserGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RemoveRoleFromUserGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RemoveRoleFromUserGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RemoveRoleFromUserGroupResult struct {
	Success *auth.OperationResult
}

var RemoveRoleFromUserGroupResult_Success_DEFAULT *auth.OperationResult

func (p *RemoveRoleFromUserGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RemoveRoleFromUserGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RemoveRoleFromUserGroupResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return RemoveRoleFromUserGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RemoveRoleFromUserGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *RemoveRoleFromUserGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoveRoleFromUserGroupResult) GetResult() interface{} {
	return p.Success
}

func getUserGroupPermissionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserGroupPermissionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserGroupPermissions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserGroupPermissionsArgs:
		success, err := handler.(auth.AuthService).GetUserGroupPermissions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserGroupPermissionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserGroupPermissionsArgs() interface{} {
	return &GetUserGroupPermissionsArgs{}
}

func newGetUserGroupPermissionsResult() interface{} {
	return &GetUserGroupPermissionsResult{}
}

type GetUserGroupPermissionsArgs struct {
	Req *auth.GetUserGroupPermissionsReq
}

func (p *GetUserGroupPermissionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserGroupPermissionsArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupPermissionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserGroupPermissionsArgs_Req_DEFAULT *auth.GetUserGroupPermissionsReq

func (p *GetUserGroupPermissionsArgs) GetReq() *auth.GetUserGroupPermissionsReq {
	if !p.IsSetReq() {
		return GetUserGroupPermissionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserGroupPermissionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserGroupPermissionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserGroupPermissionsResult struct {
	Success *auth.GetUserGroupPermissionsResp
}

var GetUserGroupPermissionsResult_Success_DEFAULT *auth.GetUserGroupPermissionsResp

func (p *GetUserGroupPermissionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserGroupPermissionsResult) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupPermissionsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserGroupPermissionsResult) GetSuccess() *auth.GetUserGroupPermissionsResp {
	if !p.IsSetSuccess() {
		return GetUserGroupPermissionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserGroupPermissionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetUserGroupPermissionsResp)
}

func (p *GetUserGroupPermissionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserGroupPermissionsResult) GetResult() interface{} {
	return p.Success
}

func assignUserToGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.AssignUserToGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).AssignUserToGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AssignUserToGroupArgs:
		success, err := handler.(auth.AuthService).AssignUserToGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AssignUserToGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAssignUserToGroupArgs() interface{} {
	return &AssignUserToGroupArgs{}
}

func newAssignUserToGroupResult() interface{} {
	return &AssignUserToGroupResult{}
}

type AssignUserToGroupArgs struct {
	Req *auth.AssignUserToGroupReq
}

func (p *AssignUserToGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AssignUserToGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.AssignUserToGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AssignUserToGroupArgs_Req_DEFAULT *auth.AssignUserToGroupReq

func (p *AssignUserToGroupArgs) GetReq() *auth.AssignUserToGroupReq {
	if !p.IsSetReq() {
		return AssignUserToGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AssignUserToGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AssignUserToGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AssignUserToGroupResult struct {
	Success *auth.OperationResult
}

var AssignUserToGroupResult_Success_DEFAULT *auth.OperationResult

func (p *AssignUserToGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AssignUserToGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AssignUserToGroupResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return AssignUserToGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AssignUserToGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *AssignUserToGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AssignUserToGroupResult) GetResult() interface{} {
	return p.Success
}

func removeUserFromGroupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.RemoveUserFromGroupReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).RemoveUserFromGroup(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RemoveUserFromGroupArgs:
		success, err := handler.(auth.AuthService).RemoveUserFromGroup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RemoveUserFromGroupResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRemoveUserFromGroupArgs() interface{} {
	return &RemoveUserFromGroupArgs{}
}

func newRemoveUserFromGroupResult() interface{} {
	return &RemoveUserFromGroupResult{}
}

type RemoveUserFromGroupArgs struct {
	Req *auth.RemoveUserFromGroupReq
}

func (p *RemoveUserFromGroupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RemoveUserFromGroupArgs) Unmarshal(in []byte) error {
	msg := new(auth.RemoveUserFromGroupReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RemoveUserFromGroupArgs_Req_DEFAULT *auth.RemoveUserFromGroupReq

func (p *RemoveUserFromGroupArgs) GetReq() *auth.RemoveUserFromGroupReq {
	if !p.IsSetReq() {
		return RemoveUserFromGroupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RemoveUserFromGroupArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RemoveUserFromGroupArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RemoveUserFromGroupResult struct {
	Success *auth.OperationResult
}

var RemoveUserFromGroupResult_Success_DEFAULT *auth.OperationResult

func (p *RemoveUserFromGroupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RemoveUserFromGroupResult) Unmarshal(in []byte) error {
	msg := new(auth.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RemoveUserFromGroupResult) GetSuccess() *auth.OperationResult {
	if !p.IsSetSuccess() {
		return RemoveUserFromGroupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RemoveUserFromGroupResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.OperationResult)
}

func (p *RemoveUserFromGroupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RemoveUserFromGroupResult) GetResult() interface{} {
	return p.Success
}

func getUserGroupsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserGroupsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserGroups(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserGroupsArgs:
		success, err := handler.(auth.AuthService).GetUserGroups(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserGroupsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserGroupsArgs() interface{} {
	return &GetUserGroupsArgs{}
}

func newGetUserGroupsResult() interface{} {
	return &GetUserGroupsResult{}
}

type GetUserGroupsArgs struct {
	Req *auth.GetUserGroupsReq
}

func (p *GetUserGroupsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserGroupsArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserGroupsArgs_Req_DEFAULT *auth.GetUserGroupsReq

func (p *GetUserGroupsArgs) GetReq() *auth.GetUserGroupsReq {
	if !p.IsSetReq() {
		return GetUserGroupsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserGroupsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserGroupsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserGroupsResult struct {
	Success *auth.GetUserGroupsResp
}

var GetUserGroupsResult_Success_DEFAULT *auth.GetUserGroupsResp

func (p *GetUserGroupsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserGroupsResult) Unmarshal(in []byte) error {
	msg := new(auth.GetUserGroupsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserGroupsResult) GetSuccess() *auth.GetUserGroupsResp {
	if !p.IsSetSuccess() {
		return GetUserGroupsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserGroupsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetUserGroupsResp)
}

func (p *GetUserGroupsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserGroupsResult) GetResult() interface{} {
	return p.Success
}

func getUserPermissionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.GetUserPermissionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).GetUserPermissions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserPermissionsArgs:
		success, err := handler.(auth.AuthService).GetUserPermissions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserPermissionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserPermissionsArgs() interface{} {
	return &GetUserPermissionsArgs{}
}

func newGetUserPermissionsResult() interface{} {
	return &GetUserPermissionsResult{}
}

type GetUserPermissionsArgs struct {
	Req *auth.GetUserPermissionsReq
}

func (p *GetUserPermissionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserPermissionsArgs) Unmarshal(in []byte) error {
	msg := new(auth.GetUserPermissionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserPermissionsArgs_Req_DEFAULT *auth.GetUserPermissionsReq

func (p *GetUserPermissionsArgs) GetReq() *auth.GetUserPermissionsReq {
	if !p.IsSetReq() {
		return GetUserPermissionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserPermissionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserPermissionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserPermissionsResult struct {
	Success *auth.GetUserPermissionsResp
}

var GetUserPermissionsResult_Success_DEFAULT *auth.GetUserPermissionsResp

func (p *GetUserPermissionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserPermissionsResult) Unmarshal(in []byte) error {
	msg := new(auth.GetUserPermissionsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserPermissionsResult) GetSuccess() *auth.GetUserPermissionsResp {
	if !p.IsSetSuccess() {
		return GetUserPermissionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserPermissionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.GetUserPermissionsResp)
}

func (p *GetUserPermissionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserPermissionsResult) GetResult() interface{} {
	return p.Success
}

func hasPermissionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.HasPermissionReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).HasPermission(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *HasPermissionArgs:
		success, err := handler.(auth.AuthService).HasPermission(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*HasPermissionResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newHasPermissionArgs() interface{} {
	return &HasPermissionArgs{}
}

func newHasPermissionResult() interface{} {
	return &HasPermissionResult{}
}

type HasPermissionArgs struct {
	Req *auth.HasPermissionReq
}

func (p *HasPermissionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *HasPermissionArgs) Unmarshal(in []byte) error {
	msg := new(auth.HasPermissionReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var HasPermissionArgs_Req_DEFAULT *auth.HasPermissionReq

func (p *HasPermissionArgs) GetReq() *auth.HasPermissionReq {
	if !p.IsSetReq() {
		return HasPermissionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *HasPermissionArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *HasPermissionArgs) GetFirstArgument() interface{} {
	return p.Req
}

type HasPermissionResult struct {
	Success *auth.HasPermissionResp
}

var HasPermissionResult_Success_DEFAULT *auth.HasPermissionResp

func (p *HasPermissionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *HasPermissionResult) Unmarshal(in []byte) error {
	msg := new(auth.HasPermissionResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *HasPermissionResult) GetSuccess() *auth.HasPermissionResp {
	if !p.IsSetSuccess() {
		return HasPermissionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *HasPermissionResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.HasPermissionResp)
}

func (p *HasPermissionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *HasPermissionResult) GetResult() interface{} {
	return p.Success
}

func canAccessHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.CanAccessReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).CanAccess(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CanAccessArgs:
		success, err := handler.(auth.AuthService).CanAccess(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CanAccessResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCanAccessArgs() interface{} {
	return &CanAccessArgs{}
}

func newCanAccessResult() interface{} {
	return &CanAccessResult{}
}

type CanAccessArgs struct {
	Req *auth.CanAccessReq
}

func (p *CanAccessArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CanAccessArgs) Unmarshal(in []byte) error {
	msg := new(auth.CanAccessReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CanAccessArgs_Req_DEFAULT *auth.CanAccessReq

func (p *CanAccessArgs) GetReq() *auth.CanAccessReq {
	if !p.IsSetReq() {
		return CanAccessArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CanAccessArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CanAccessArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CanAccessResult struct {
	Success *auth.CanAccessResp
}

var CanAccessResult_Success_DEFAULT *auth.CanAccessResp

func (p *CanAccessResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CanAccessResult) Unmarshal(in []byte) error {
	msg := new(auth.CanAccessResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CanAccessResult) GetSuccess() *auth.CanAccessResp {
	if !p.IsSetSuccess() {
		return CanAccessResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CanAccessResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.CanAccessResp)
}

func (p *CanAccessResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CanAccessResult) GetResult() interface{} {
	return p.Success
}

func listRolesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.ListRolesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).ListRoles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListRolesArgs:
		success, err := handler.(auth.AuthService).ListRoles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListRolesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListRolesArgs() interface{} {
	return &ListRolesArgs{}
}

func newListRolesResult() interface{} {
	return &ListRolesResult{}
}

type ListRolesArgs struct {
	Req *auth.ListRolesReq
}

func (p *ListRolesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListRolesArgs) Unmarshal(in []byte) error {
	msg := new(auth.ListRolesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListRolesArgs_Req_DEFAULT *auth.ListRolesReq

func (p *ListRolesArgs) GetReq() *auth.ListRolesReq {
	if !p.IsSetReq() {
		return ListRolesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListRolesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListRolesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListRolesResult struct {
	Success *auth.ListRolesResp
}

var ListRolesResult_Success_DEFAULT *auth.ListRolesResp

func (p *ListRolesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListRolesResult) Unmarshal(in []byte) error {
	msg := new(auth.ListRolesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListRolesResult) GetSuccess() *auth.ListRolesResp {
	if !p.IsSetSuccess() {
		return ListRolesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListRolesResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.ListRolesResp)
}

func (p *ListRolesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListRolesResult) GetResult() interface{} {
	return p.Success
}

func listUserGroupsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.ListUserGroupsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).ListUserGroups(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListUserGroupsArgs:
		success, err := handler.(auth.AuthService).ListUserGroups(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListUserGroupsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListUserGroupsArgs() interface{} {
	return &ListUserGroupsArgs{}
}

func newListUserGroupsResult() interface{} {
	return &ListUserGroupsResult{}
}

type ListUserGroupsArgs struct {
	Req *auth.ListUserGroupsReq
}

func (p *ListUserGroupsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListUserGroupsArgs) Unmarshal(in []byte) error {
	msg := new(auth.ListUserGroupsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListUserGroupsArgs_Req_DEFAULT *auth.ListUserGroupsReq

func (p *ListUserGroupsArgs) GetReq() *auth.ListUserGroupsReq {
	if !p.IsSetReq() {
		return ListUserGroupsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListUserGroupsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListUserGroupsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListUserGroupsResult struct {
	Success *auth.ListUserGroupsResp
}

var ListUserGroupsResult_Success_DEFAULT *auth.ListUserGroupsResp

func (p *ListUserGroupsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListUserGroupsResult) Unmarshal(in []byte) error {
	msg := new(auth.ListUserGroupsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListUserGroupsResult) GetSuccess() *auth.ListUserGroupsResp {
	if !p.IsSetSuccess() {
		return ListUserGroupsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListUserGroupsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.ListUserGroupsResp)
}

func (p *ListUserGroupsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListUserGroupsResult) GetResult() interface{} {
	return p.Success
}

func listPermissionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.ListPermissionsReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).ListPermissions(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListPermissionsArgs:
		success, err := handler.(auth.AuthService).ListPermissions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListPermissionsResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListPermissionsArgs() interface{} {
	return &ListPermissionsArgs{}
}

func newListPermissionsResult() interface{} {
	return &ListPermissionsResult{}
}

type ListPermissionsArgs struct {
	Req *auth.ListPermissionsReq
}

func (p *ListPermissionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListPermissionsArgs) Unmarshal(in []byte) error {
	msg := new(auth.ListPermissionsReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListPermissionsArgs_Req_DEFAULT *auth.ListPermissionsReq

func (p *ListPermissionsArgs) GetReq() *auth.ListPermissionsReq {
	if !p.IsSetReq() {
		return ListPermissionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListPermissionsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListPermissionsArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListPermissionsResult struct {
	Success *auth.ListPermissionsResp
}

var ListPermissionsResult_Success_DEFAULT *auth.ListPermissionsResp

func (p *ListPermissionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListPermissionsResult) Unmarshal(in []byte) error {
	msg := new(auth.ListPermissionsResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListPermissionsResult) GetSuccess() *auth.ListPermissionsResp {
	if !p.IsSetSuccess() {
		return ListPermissionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListPermissionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.ListPermissionsResp)
}

func (p *ListPermissionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListPermissionsResult) GetResult() interface{} {
	return p.Success
}

func issueTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.IssueTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).IssueToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *IssueTokenArgs:
		success, err := handler.(auth.AuthService).IssueToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*IssueTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newIssueTokenArgs() interface{} {
	return &IssueTokenArgs{}
}

func newIssueTokenResult() interface{} {
	return &IssueTokenResult{}
}

type IssueTokenArgs struct {
	Req *auth.IssueTokenReq
}

func (p *IssueTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *IssueTokenArgs) Unmarshal(in []byte) error {
	msg := new(auth.IssueTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var IssueTokenArgs_Req_DEFAULT *auth.IssueTokenReq

func (p *IssueTokenArgs) GetReq() *auth.IssueTokenReq {
	if !p.IsSetReq() {
		return IssueTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *IssueTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *IssueTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type IssueTokenResult struct {
	Success *auth.IssueTokenResp
}

var IssueTokenResult_Success_DEFAULT *auth.IssueTokenResp

func (p *IssueTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *IssueTokenResult) Unmarshal(in []byte) error {
	msg := new(auth.IssueTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *IssueTokenResult) GetSuccess() *auth.IssueTokenResp {
	if !p.IsSetSuccess() {
		return IssueTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *IssueTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.IssueTokenResp)
}

func (p *IssueTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IssueTokenResult) GetResult() interface{} {
	return p.Success
}

func refreshTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.RefreshTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).RefreshToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RefreshTokenArgs:
		success, err := handler.(auth.AuthService).RefreshToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RefreshTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRefreshTokenArgs() interface{} {
	return &RefreshTokenArgs{}
}

func newRefreshTokenResult() interface{} {
	return &RefreshTokenResult{}
}

type RefreshTokenArgs struct {
	Req *auth.RefreshTokenReq
}

func (p *RefreshTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RefreshTokenArgs) Unmarshal(in []byte) error {
	msg := new(auth.RefreshTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RefreshTokenArgs_Req_DEFAULT *auth.RefreshTokenReq

func (p *RefreshTokenArgs) GetReq() *auth.RefreshTokenReq {
	if !p.IsSetReq() {
		return RefreshTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RefreshTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RefreshTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RefreshTokenResult struct {
	Success *auth.RefreshTokenResp
}

var RefreshTokenResult_Success_DEFAULT *auth.RefreshTokenResp

func (p *RefreshTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RefreshTokenResult) Unmarshal(in []byte) error {
	msg := new(auth.RefreshTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RefreshTokenResult) GetSuccess() *auth.RefreshTokenResp {
	if !p.IsSetSuccess() {
		return RefreshTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RefreshTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.RefreshTokenResp)
}

func (p *RefreshTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RefreshTokenResult) GetResult() interface{} {
	return p.Success
}

func verifyTokenHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(auth.VerifyTokenReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(auth.AuthService).VerifyToken(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyTokenArgs:
		success, err := handler.(auth.AuthService).VerifyToken(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyTokenResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyTokenArgs() interface{} {
	return &VerifyTokenArgs{}
}

func newVerifyTokenResult() interface{} {
	return &VerifyTokenResult{}
}

type VerifyTokenArgs struct {
	Req *auth.VerifyTokenReq
}

func (p *VerifyTokenArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyTokenArgs) Unmarshal(in []byte) error {
	msg := new(auth.VerifyTokenReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyTokenArgs_Req_DEFAULT *auth.VerifyTokenReq

func (p *VerifyTokenArgs) GetReq() *auth.VerifyTokenReq {
	if !p.IsSetReq() {
		return VerifyTokenArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyTokenArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyTokenArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyTokenResult struct {
	Success *auth.VerifyTokenResp
}

var VerifyTokenResult_Success_DEFAULT *auth.VerifyTokenResp

func (p *VerifyTokenResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyTokenResult) Unmarshal(in []byte) error {
	msg := new(auth.VerifyTokenResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyTokenResult) GetSuccess() *auth.VerifyTokenResp {
	if !p.IsSetSuccess() {
		return VerifyTokenResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyTokenResult) SetSuccess(x interface{}) {
	p.Success = x.(*auth.VerifyTokenResp)
}

func (p *VerifyTokenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyTokenResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreatePermission(ctx context.Context, Req *auth.CreatePermissionReq) (r *auth.Permission, err error) {
	var _args CreatePermissionArgs
	_args.Req = Req
	var _result CreatePermissionResult
	if err = p.c.Call(ctx, "CreatePermission", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdatePermission(ctx context.Context, Req *auth.UpdatePermissionReq) (r *auth.Permission, err error) {
	var _args UpdatePermissionArgs
	_args.Req = Req
	var _result UpdatePermissionResult
	if err = p.c.Call(ctx, "UpdatePermission", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeletePermission(ctx context.Context, Req *auth.DeletePermissionReq) (r *auth.OperationResult, err error) {
	var _args DeletePermissionArgs
	_args.Req = Req
	var _result DeletePermissionResult
	if err = p.c.Call(ctx, "DeletePermission", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPermission(ctx context.Context, Req *auth.GetPermissionReq) (r *auth.Permission, err error) {
	var _args GetPermissionArgs
	_args.Req = Req
	var _result GetPermissionResult
	if err = p.c.Call(ctx, "GetPermission", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateRole(ctx context.Context, Req *auth.CreateRoleReq) (r *auth.Role, err error) {
	var _args CreateRoleArgs
	_args.Req = Req
	var _result CreateRoleResult
	if err = p.c.Call(ctx, "CreateRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateRole(ctx context.Context, Req *auth.UpdateRoleReq) (r *auth.Role, err error) {
	var _args UpdateRoleArgs
	_args.Req = Req
	var _result UpdateRoleResult
	if err = p.c.Call(ctx, "UpdateRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteRole(ctx context.Context, Req *auth.DeleteRoleReq) (r *auth.OperationResult, err error) {
	var _args DeleteRoleArgs
	_args.Req = Req
	var _result DeleteRoleResult
	if err = p.c.Call(ctx, "DeleteRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRole(ctx context.Context, Req *auth.GetRoleReq) (r *auth.Role, err error) {
	var _args GetRoleArgs
	_args.Req = Req
	var _result GetRoleResult
	if err = p.c.Call(ctx, "GetRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GrantPermissionToRole(ctx context.Context, Req *auth.GrantPermissionToRoleReq) (r *auth.OperationResult, err error) {
	var _args GrantPermissionToRoleArgs
	_args.Req = Req
	var _result GrantPermissionToRoleResult
	if err = p.c.Call(ctx, "GrantPermissionToRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RevokePermissionFromRole(ctx context.Context, Req *auth.RevokePermissionFromRoleReq) (r *auth.OperationResult, err error) {
	var _args RevokePermissionFromRoleArgs
	_args.Req = Req
	var _result RevokePermissionFromRoleResult
	if err = p.c.Call(ctx, "RevokePermissionFromRole", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRolePermissions(ctx context.Context, Req *auth.GetRolePermissionsReq) (r *auth.GetRolePermissionsResp, err error) {
	var _args GetRolePermissionsArgs
	_args.Req = Req
	var _result GetRolePermissionsResult
	if err = p.c.Call(ctx, "GetRolePermissions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AssignRoleToUser(ctx context.Context, Req *auth.AssignRoleToUserReq) (r *auth.OperationResult, err error) {
	var _args AssignRoleToUserArgs
	_args.Req = Req
	var _result AssignRoleToUserResult
	if err = p.c.Call(ctx, "AssignRoleToUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RemoveRoleFromUser(ctx context.Context, Req *auth.RemoveRoleFromUserReq) (r *auth.OperationResult, err error) {
	var _args RemoveRoleFromUserArgs
	_args.Req = Req
	var _result RemoveRoleFromUserResult
	if err = p.c.Call(ctx, "RemoveRoleFromUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserRoles(ctx context.Context, Req *auth.GetUserRolesReq) (r *auth.GetUserRolesResp, err error) {
	var _args GetUserRolesArgs
	_args.Req = Req
	var _result GetUserRolesResult
	if err = p.c.Call(ctx, "GetUserRoles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateUserGroup(ctx context.Context, Req *auth.CreateUserGroupReq) (r *auth.UserGroup, err error) {
	var _args CreateUserGroupArgs
	_args.Req = Req
	var _result CreateUserGroupResult
	if err = p.c.Call(ctx, "CreateUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUserGroup(ctx context.Context, Req *auth.UpdateUserGroupReq) (r *auth.UserGroup, err error) {
	var _args UpdateUserGroupArgs
	_args.Req = Req
	var _result UpdateUserGroupResult
	if err = p.c.Call(ctx, "UpdateUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUserGroup(ctx context.Context, Req *auth.DeleteUserGroupReq) (r *auth.OperationResult, err error) {
	var _args DeleteUserGroupArgs
	_args.Req = Req
	var _result DeleteUserGroupResult
	if err = p.c.Call(ctx, "DeleteUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserGroup(ctx context.Context, Req *auth.GetUserGroupReq) (r *auth.UserGroup, err error) {
	var _args GetUserGroupArgs
	_args.Req = Req
	var _result GetUserGroupResult
	if err = p.c.Call(ctx, "GetUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserGroupMembers(ctx context.Context, Req *auth.GetUserGroupMembersReq) (r *auth.GetUserGroupMembersResp, err error) {
	var _args GetUserGroupMembersArgs
	_args.Req = Req
	var _result GetUserGroupMembersResult
	if err = p.c.Call(ctx, "GetUserGroupMembers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AssignRoleToUserGroup(ctx context.Context, Req *auth.AssignRoleToUserGroupReq) (r *auth.OperationResult, err error) {
	var _args AssignRoleToUserGroupArgs
	_args.Req = Req
	var _result AssignRoleToUserGroupResult
	if err = p.c.Call(ctx, "AssignRoleToUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RemoveRoleFromUserGroup(ctx context.Context, Req *auth.RemoveRoleFromUserGroupReq) (r *auth.OperationResult, err error) {
	var _args RemoveRoleFromUserGroupArgs
	_args.Req = Req
	var _result RemoveRoleFromUserGroupResult
	if err = p.c.Call(ctx, "RemoveRoleFromUserGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserGroupPermissions(ctx context.Context, Req *auth.GetUserGroupPermissionsReq) (r *auth.GetUserGroupPermissionsResp, err error) {
	var _args GetUserGroupPermissionsArgs
	_args.Req = Req
	var _result GetUserGroupPermissionsResult
	if err = p.c.Call(ctx, "GetUserGroupPermissions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AssignUserToGroup(ctx context.Context, Req *auth.AssignUserToGroupReq) (r *auth.OperationResult, err error) {
	var _args AssignUserToGroupArgs
	_args.Req = Req
	var _result AssignUserToGroupResult
	if err = p.c.Call(ctx, "AssignUserToGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RemoveUserFromGroup(ctx context.Context, Req *auth.RemoveUserFromGroupReq) (r *auth.OperationResult, err error) {
	var _args RemoveUserFromGroupArgs
	_args.Req = Req
	var _result RemoveUserFromGroupResult
	if err = p.c.Call(ctx, "RemoveUserFromGroup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserGroups(ctx context.Context, Req *auth.GetUserGroupsReq) (r *auth.GetUserGroupsResp, err error) {
	var _args GetUserGroupsArgs
	_args.Req = Req
	var _result GetUserGroupsResult
	if err = p.c.Call(ctx, "GetUserGroups", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserPermissions(ctx context.Context, Req *auth.GetUserPermissionsReq) (r *auth.GetUserPermissionsResp, err error) {
	var _args GetUserPermissionsArgs
	_args.Req = Req
	var _result GetUserPermissionsResult
	if err = p.c.Call(ctx, "GetUserPermissions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) HasPermission(ctx context.Context, Req *auth.HasPermissionReq) (r *auth.HasPermissionResp, err error) {
	var _args HasPermissionArgs
	_args.Req = Req
	var _result HasPermissionResult
	if err = p.c.Call(ctx, "HasPermission", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CanAccess(ctx context.Context, Req *auth.CanAccessReq) (r *auth.CanAccessResp, err error) {
	var _args CanAccessArgs
	_args.Req = Req
	var _result CanAccessResult
	if err = p.c.Call(ctx, "CanAccess", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListRoles(ctx context.Context, Req *auth.ListRolesReq) (r *auth.ListRolesResp, err error) {
	var _args ListRolesArgs
	_args.Req = Req
	var _result ListRolesResult
	if err = p.c.Call(ctx, "ListRoles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListUserGroups(ctx context.Context, Req *auth.ListUserGroupsReq) (r *auth.ListUserGroupsResp, err error) {
	var _args ListUserGroupsArgs
	_args.Req = Req
	var _result ListUserGroupsResult
	if err = p.c.Call(ctx, "ListUserGroups", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListPermissions(ctx context.Context, Req *auth.ListPermissionsReq) (r *auth.ListPermissionsResp, err error) {
	var _args ListPermissionsArgs
	_args.Req = Req
	var _result ListPermissionsResult
	if err = p.c.Call(ctx, "ListPermissions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) IssueToken(ctx context.Context, Req *auth.IssueTokenReq) (r *auth.IssueTokenResp, err error) {
	var _args IssueTokenArgs
	_args.Req = Req
	var _result IssueTokenResult
	if err = p.c.Call(ctx, "IssueToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RefreshToken(ctx context.Context, Req *auth.RefreshTokenReq) (r *auth.RefreshTokenResp, err error) {
	var _args RefreshTokenArgs
	_args.Req = Req
	var _result RefreshTokenResult
	if err = p.c.Call(ctx, "RefreshToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyToken(ctx context.Context, Req *auth.VerifyTokenReq) (r *auth.VerifyTokenResp, err error) {
	var _args VerifyTokenArgs
	_args.Req = Req
	var _result VerifyTokenResult
	if err = p.c.Call(ctx, "VerifyToken", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
