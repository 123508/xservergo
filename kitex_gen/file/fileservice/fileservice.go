// Code generated by Kitex v0.14.1. DO NOT EDIT.

package fileservice

import (
	"context"
	"errors"
	file "github.com/123508/xservergo/kitex_gen/file"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"InitUpload": kitex.NewMethodInfo(
		initUploadHandler,
		newInitUploadArgs,
		newInitUploadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UploadChunk": kitex.NewMethodInfo(
		uploadChunkHandler,
		newUploadChunkArgs,
		newUploadChunkResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UploadVerify": kitex.NewMethodInfo(
		uploadVerifyHandler,
		newUploadVerifyArgs,
		newUploadVerifyResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DirectUpload": kitex.NewMethodInfo(
		directUploadHandler,
		newDirectUploadArgs,
		newDirectUploadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PreDownLoad": kitex.NewMethodInfo(
		preDownLoadHandler,
		newPreDownLoadArgs,
		newPreDownLoadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Download": kitex.NewMethodInfo(
		downloadHandler,
		newDownloadArgs,
		newDownloadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateFolder": kitex.NewMethodInfo(
		createFolderHandler,
		newCreateFolderArgs,
		newCreateFolderResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RenameFile": kitex.NewMethodInfo(
		renameFileHandler,
		newRenameFileArgs,
		newRenameFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"TransferSave": kitex.NewMethodInfo(
		transferSaveHandler,
		newTransferSaveArgs,
		newTransferSaveResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"MoveFile": kitex.NewMethodInfo(
		moveFileHandler,
		newMoveFileArgs,
		newMoveFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"TrashFile": kitex.NewMethodInfo(
		trashFileHandler,
		newTrashFileArgs,
		newTrashFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteFile": kitex.NewMethodInfo(
		deleteFileHandler,
		newDeleteFileArgs,
		newDeleteFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RestoreFile": kitex.NewMethodInfo(
		restoreFileHandler,
		newRestoreFileArgs,
		newRestoreFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetFileMeta": kitex.NewMethodInfo(
		getFileMetaHandler,
		newGetFileMetaArgs,
		newGetFileMetaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListDirectory": kitex.NewMethodInfo(
		listDirectoryHandler,
		newListDirectoryArgs,
		newListDirectoryResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchFiles": kitex.NewMethodInfo(
		searchFilesHandler,
		newSearchFilesArgs,
		newSearchFilesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"BuildSharedUrl": kitex.NewMethodInfo(
		buildSharedUrlHandler,
		newBuildSharedUrlArgs,
		newBuildSharedUrlResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetPreviewUrl": kitex.NewMethodInfo(
		getPreviewUrlHandler,
		newGetPreviewUrlArgs,
		newGetPreviewUrlResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetTranscodeStatus": kitex.NewMethodInfo(
		getTranscodeStatusHandler,
		newGetTranscodeStatusArgs,
		newGetTranscodeStatusResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GenerateDocumentPreview": kitex.NewMethodInfo(
		generateDocumentPreviewHandler,
		newGenerateDocumentPreviewArgs,
		newGenerateDocumentPreviewResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CleanTrash": kitex.NewMethodInfo(
		cleanTrashHandler,
		newCleanTrashArgs,
		newCleanTrashResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetStorageQuota": kitex.NewMethodInfo(
		getStorageQuotaHandler,
		newGetStorageQuotaArgs,
		newGetStorageQuotaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	fileServiceServiceInfo                = NewServiceInfo()
	fileServiceServiceInfoForClient       = NewServiceInfoForClient()
	fileServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return fileServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "FileService"
	handlerType := (*file.FileService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "file",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func initUploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.InitUploadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).InitUpload(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *InitUploadArgs:
		success, err := handler.(file.FileService).InitUpload(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*InitUploadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newInitUploadArgs() interface{} {
	return &InitUploadArgs{}
}

func newInitUploadResult() interface{} {
	return &InitUploadResult{}
}

type InitUploadArgs struct {
	Req *file.InitUploadReq
}

func (p *InitUploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *InitUploadArgs) Unmarshal(in []byte) error {
	msg := new(file.InitUploadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var InitUploadArgs_Req_DEFAULT *file.InitUploadReq

func (p *InitUploadArgs) GetReq() *file.InitUploadReq {
	if !p.IsSetReq() {
		return InitUploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *InitUploadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *InitUploadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type InitUploadResult struct {
	Success *file.InitUploadResp
}

var InitUploadResult_Success_DEFAULT *file.InitUploadResp

func (p *InitUploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *InitUploadResult) Unmarshal(in []byte) error {
	msg := new(file.InitUploadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *InitUploadResult) GetSuccess() *file.InitUploadResp {
	if !p.IsSetSuccess() {
		return InitUploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *InitUploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.InitUploadResp)
}

func (p *InitUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *InitUploadResult) GetResult() interface{} {
	return p.Success
}

func uploadChunkHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UploadChunkReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).UploadChunk(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UploadChunkArgs:
		success, err := handler.(file.FileService).UploadChunk(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadChunkResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUploadChunkArgs() interface{} {
	return &UploadChunkArgs{}
}

func newUploadChunkResult() interface{} {
	return &UploadChunkResult{}
}

type UploadChunkArgs struct {
	Req *file.UploadChunkReq
}

func (p *UploadChunkArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UploadChunkArgs) Unmarshal(in []byte) error {
	msg := new(file.UploadChunkReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadChunkArgs_Req_DEFAULT *file.UploadChunkReq

func (p *UploadChunkArgs) GetReq() *file.UploadChunkReq {
	if !p.IsSetReq() {
		return UploadChunkArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadChunkArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UploadChunkArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UploadChunkResult struct {
	Success *file.UploadChunkResp
}

var UploadChunkResult_Success_DEFAULT *file.UploadChunkResp

func (p *UploadChunkResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UploadChunkResult) Unmarshal(in []byte) error {
	msg := new(file.UploadChunkResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadChunkResult) GetSuccess() *file.UploadChunkResp {
	if !p.IsSetSuccess() {
		return UploadChunkResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadChunkResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.UploadChunkResp)
}

func (p *UploadChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UploadChunkResult) GetResult() interface{} {
	return p.Success
}

func uploadVerifyHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UploadVerifyReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).UploadVerify(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UploadVerifyArgs:
		success, err := handler.(file.FileService).UploadVerify(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadVerifyResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUploadVerifyArgs() interface{} {
	return &UploadVerifyArgs{}
}

func newUploadVerifyResult() interface{} {
	return &UploadVerifyResult{}
}

type UploadVerifyArgs struct {
	Req *file.UploadVerifyReq
}

func (p *UploadVerifyArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UploadVerifyArgs) Unmarshal(in []byte) error {
	msg := new(file.UploadVerifyReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadVerifyArgs_Req_DEFAULT *file.UploadVerifyReq

func (p *UploadVerifyArgs) GetReq() *file.UploadVerifyReq {
	if !p.IsSetReq() {
		return UploadVerifyArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadVerifyArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UploadVerifyArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UploadVerifyResult struct {
	Success *file.UploadVerifyResp
}

var UploadVerifyResult_Success_DEFAULT *file.UploadVerifyResp

func (p *UploadVerifyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UploadVerifyResult) Unmarshal(in []byte) error {
	msg := new(file.UploadVerifyResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadVerifyResult) GetSuccess() *file.UploadVerifyResp {
	if !p.IsSetSuccess() {
		return UploadVerifyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadVerifyResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.UploadVerifyResp)
}

func (p *UploadVerifyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UploadVerifyResult) GetResult() interface{} {
	return p.Success
}

func directUploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.DirectUploadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DirectUpload(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DirectUploadArgs:
		success, err := handler.(file.FileService).DirectUpload(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DirectUploadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDirectUploadArgs() interface{} {
	return &DirectUploadArgs{}
}

func newDirectUploadResult() interface{} {
	return &DirectUploadResult{}
}

type DirectUploadArgs struct {
	Req *file.DirectUploadReq
}

func (p *DirectUploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DirectUploadArgs) Unmarshal(in []byte) error {
	msg := new(file.DirectUploadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DirectUploadArgs_Req_DEFAULT *file.DirectUploadReq

func (p *DirectUploadArgs) GetReq() *file.DirectUploadReq {
	if !p.IsSetReq() {
		return DirectUploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DirectUploadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DirectUploadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DirectUploadResult struct {
	Success *file.DirectUploadResp
}

var DirectUploadResult_Success_DEFAULT *file.DirectUploadResp

func (p *DirectUploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DirectUploadResult) Unmarshal(in []byte) error {
	msg := new(file.DirectUploadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DirectUploadResult) GetSuccess() *file.DirectUploadResp {
	if !p.IsSetSuccess() {
		return DirectUploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DirectUploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.DirectUploadResp)
}

func (p *DirectUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DirectUploadResult) GetResult() interface{} {
	return p.Success
}

func preDownLoadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.PreDownLoadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).PreDownLoad(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PreDownLoadArgs:
		success, err := handler.(file.FileService).PreDownLoad(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PreDownLoadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPreDownLoadArgs() interface{} {
	return &PreDownLoadArgs{}
}

func newPreDownLoadResult() interface{} {
	return &PreDownLoadResult{}
}

type PreDownLoadArgs struct {
	Req *file.PreDownLoadReq
}

func (p *PreDownLoadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PreDownLoadArgs) Unmarshal(in []byte) error {
	msg := new(file.PreDownLoadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PreDownLoadArgs_Req_DEFAULT *file.PreDownLoadReq

func (p *PreDownLoadArgs) GetReq() *file.PreDownLoadReq {
	if !p.IsSetReq() {
		return PreDownLoadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PreDownLoadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PreDownLoadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PreDownLoadResult struct {
	Success *file.PreDownloadResp
}

var PreDownLoadResult_Success_DEFAULT *file.PreDownloadResp

func (p *PreDownLoadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PreDownLoadResult) Unmarshal(in []byte) error {
	msg := new(file.PreDownloadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PreDownLoadResult) GetSuccess() *file.PreDownloadResp {
	if !p.IsSetSuccess() {
		return PreDownLoadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PreDownLoadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.PreDownloadResp)
}

func (p *PreDownLoadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PreDownLoadResult) GetResult() interface{} {
	return p.Success
}

func downloadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.DownloadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).Download(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DownloadArgs:
		success, err := handler.(file.FileService).Download(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DownloadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDownloadArgs() interface{} {
	return &DownloadArgs{}
}

func newDownloadResult() interface{} {
	return &DownloadResult{}
}

type DownloadArgs struct {
	Req *file.DownloadReq
}

func (p *DownloadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DownloadArgs) Unmarshal(in []byte) error {
	msg := new(file.DownloadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DownloadArgs_Req_DEFAULT *file.DownloadReq

func (p *DownloadArgs) GetReq() *file.DownloadReq {
	if !p.IsSetReq() {
		return DownloadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DownloadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DownloadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DownloadResult struct {
	Success *file.DownloadResp
}

var DownloadResult_Success_DEFAULT *file.DownloadResp

func (p *DownloadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DownloadResult) Unmarshal(in []byte) error {
	msg := new(file.DownloadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DownloadResult) GetSuccess() *file.DownloadResp {
	if !p.IsSetSuccess() {
		return DownloadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DownloadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.DownloadResp)
}

func (p *DownloadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DownloadResult) GetResult() interface{} {
	return p.Success
}

func createFolderHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CreateFolderReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CreateFolder(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateFolderArgs:
		success, err := handler.(file.FileService).CreateFolder(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateFolderResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateFolderArgs() interface{} {
	return &CreateFolderArgs{}
}

func newCreateFolderResult() interface{} {
	return &CreateFolderResult{}
}

type CreateFolderArgs struct {
	Req *file.CreateFolderReq
}

func (p *CreateFolderArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateFolderArgs) Unmarshal(in []byte) error {
	msg := new(file.CreateFolderReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateFolderArgs_Req_DEFAULT *file.CreateFolderReq

func (p *CreateFolderArgs) GetReq() *file.CreateFolderReq {
	if !p.IsSetReq() {
		return CreateFolderArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateFolderArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateFolderArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateFolderResult struct {
	Success *file.FileAliasItem
}

var CreateFolderResult_Success_DEFAULT *file.FileAliasItem

func (p *CreateFolderResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateFolderResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateFolderResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return CreateFolderResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateFolderResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *CreateFolderResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateFolderResult) GetResult() interface{} {
	return p.Success
}

func renameFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.RenameFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).RenameFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RenameFileArgs:
		success, err := handler.(file.FileService).RenameFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RenameFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRenameFileArgs() interface{} {
	return &RenameFileArgs{}
}

func newRenameFileResult() interface{} {
	return &RenameFileResult{}
}

type RenameFileArgs struct {
	Req *file.RenameFileReq
}

func (p *RenameFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RenameFileArgs) Unmarshal(in []byte) error {
	msg := new(file.RenameFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RenameFileArgs_Req_DEFAULT *file.RenameFileReq

func (p *RenameFileArgs) GetReq() *file.RenameFileReq {
	if !p.IsSetReq() {
		return RenameFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RenameFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RenameFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RenameFileResult struct {
	Success *file.FileAliasItem
}

var RenameFileResult_Success_DEFAULT *file.FileAliasItem

func (p *RenameFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RenameFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RenameFileResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return RenameFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RenameFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *RenameFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RenameFileResult) GetResult() interface{} {
	return p.Success
}

func transferSaveHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.TransferSaveReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).TransferSave(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TransferSaveArgs:
		success, err := handler.(file.FileService).TransferSave(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TransferSaveResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTransferSaveArgs() interface{} {
	return &TransferSaveArgs{}
}

func newTransferSaveResult() interface{} {
	return &TransferSaveResult{}
}

type TransferSaveArgs struct {
	Req *file.TransferSaveReq
}

func (p *TransferSaveArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TransferSaveArgs) Unmarshal(in []byte) error {
	msg := new(file.TransferSaveReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TransferSaveArgs_Req_DEFAULT *file.TransferSaveReq

func (p *TransferSaveArgs) GetReq() *file.TransferSaveReq {
	if !p.IsSetReq() {
		return TransferSaveArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TransferSaveArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TransferSaveArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TransferSaveResult struct {
	Success *file.TransferSaveResp
}

var TransferSaveResult_Success_DEFAULT *file.TransferSaveResp

func (p *TransferSaveResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TransferSaveResult) Unmarshal(in []byte) error {
	msg := new(file.TransferSaveResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TransferSaveResult) GetSuccess() *file.TransferSaveResp {
	if !p.IsSetSuccess() {
		return TransferSaveResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TransferSaveResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.TransferSaveResp)
}

func (p *TransferSaveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TransferSaveResult) GetResult() interface{} {
	return p.Success
}

func moveFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.MoveFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).MoveFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *MoveFileArgs:
		success, err := handler.(file.FileService).MoveFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MoveFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newMoveFileArgs() interface{} {
	return &MoveFileArgs{}
}

func newMoveFileResult() interface{} {
	return &MoveFileResult{}
}

type MoveFileArgs struct {
	Req *file.MoveFileReq
}

func (p *MoveFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *MoveFileArgs) Unmarshal(in []byte) error {
	msg := new(file.MoveFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MoveFileArgs_Req_DEFAULT *file.MoveFileReq

func (p *MoveFileArgs) GetReq() *file.MoveFileReq {
	if !p.IsSetReq() {
		return MoveFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MoveFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *MoveFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type MoveFileResult struct {
	Success *file.FileAliasItem
}

var MoveFileResult_Success_DEFAULT *file.FileAliasItem

func (p *MoveFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *MoveFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MoveFileResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return MoveFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MoveFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *MoveFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MoveFileResult) GetResult() interface{} {
	return p.Success
}

func trashFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).TrashFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TrashFileArgs:
		success, err := handler.(file.FileService).TrashFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TrashFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTrashFileArgs() interface{} {
	return &TrashFileArgs{}
}

func newTrashFileResult() interface{} {
	return &TrashFileResult{}
}

type TrashFileArgs struct {
	Req *file.FileReq
}

func (p *TrashFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TrashFileArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TrashFileArgs_Req_DEFAULT *file.FileReq

func (p *TrashFileArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return TrashFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TrashFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TrashFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TrashFileResult struct {
	Success *file.FileAliasItem
}

var TrashFileResult_Success_DEFAULT *file.FileAliasItem

func (p *TrashFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TrashFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TrashFileResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return TrashFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TrashFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *TrashFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TrashFileResult) GetResult() interface{} {
	return p.Success
}

func deleteFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DeleteFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteFileArgs:
		success, err := handler.(file.FileService).DeleteFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteFileArgs() interface{} {
	return &DeleteFileArgs{}
}

func newDeleteFileResult() interface{} {
	return &DeleteFileResult{}
}

type DeleteFileArgs struct {
	Req *file.FileReq
}

func (p *DeleteFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteFileArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteFileArgs_Req_DEFAULT *file.FileReq

func (p *DeleteFileArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return DeleteFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteFileResult struct {
	Success *file.FileAliasItem
}

var DeleteFileResult_Success_DEFAULT *file.FileAliasItem

func (p *DeleteFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteFileResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return DeleteFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *DeleteFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteFileResult) GetResult() interface{} {
	return p.Success
}

func restoreFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).RestoreFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RestoreFileArgs:
		success, err := handler.(file.FileService).RestoreFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RestoreFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRestoreFileArgs() interface{} {
	return &RestoreFileArgs{}
}

func newRestoreFileResult() interface{} {
	return &RestoreFileResult{}
}

type RestoreFileArgs struct {
	Req *file.FileReq
}

func (p *RestoreFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RestoreFileArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RestoreFileArgs_Req_DEFAULT *file.FileReq

func (p *RestoreFileArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return RestoreFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RestoreFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RestoreFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RestoreFileResult struct {
	Success *file.FileAliasItem
}

var RestoreFileResult_Success_DEFAULT *file.FileAliasItem

func (p *RestoreFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RestoreFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileAliasItem)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RestoreFileResult) GetSuccess() *file.FileAliasItem {
	if !p.IsSetSuccess() {
		return RestoreFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RestoreFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileAliasItem)
}

func (p *RestoreFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RestoreFileResult) GetResult() interface{} {
	return p.Success
}

func getFileMetaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetFileMeta(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetFileMetaArgs:
		success, err := handler.(file.FileService).GetFileMeta(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileMetaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetFileMetaArgs() interface{} {
	return &GetFileMetaArgs{}
}

func newGetFileMetaResult() interface{} {
	return &GetFileMetaResult{}
}

type GetFileMetaArgs struct {
	Req *file.FileReq
}

func (p *GetFileMetaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileMetaArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileMetaArgs_Req_DEFAULT *file.FileReq

func (p *GetFileMetaArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetFileMetaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileMetaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileMetaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileMetaResult struct {
	Success *file.FileMetaResp
}

var GetFileMetaResult_Success_DEFAULT *file.FileMetaResp

func (p *GetFileMetaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileMetaResult) Unmarshal(in []byte) error {
	msg := new(file.FileMetaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileMetaResult) GetSuccess() *file.FileMetaResp {
	if !p.IsSetSuccess() {
		return GetFileMetaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileMetaResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMetaResp)
}

func (p *GetFileMetaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileMetaResult) GetResult() interface{} {
	return p.Success
}

func listDirectoryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.ListDirectoryReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).ListDirectory(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListDirectoryArgs:
		success, err := handler.(file.FileService).ListDirectory(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListDirectoryResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListDirectoryArgs() interface{} {
	return &ListDirectoryArgs{}
}

func newListDirectoryResult() interface{} {
	return &ListDirectoryResult{}
}

type ListDirectoryArgs struct {
	Req *file.ListDirectoryReq
}

func (p *ListDirectoryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListDirectoryArgs) Unmarshal(in []byte) error {
	msg := new(file.ListDirectoryReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListDirectoryArgs_Req_DEFAULT *file.ListDirectoryReq

func (p *ListDirectoryArgs) GetReq() *file.ListDirectoryReq {
	if !p.IsSetReq() {
		return ListDirectoryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListDirectoryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListDirectoryArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListDirectoryResult struct {
	Success *file.ListDirectoryResp
}

var ListDirectoryResult_Success_DEFAULT *file.ListDirectoryResp

func (p *ListDirectoryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListDirectoryResult) Unmarshal(in []byte) error {
	msg := new(file.ListDirectoryResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListDirectoryResult) GetSuccess() *file.ListDirectoryResp {
	if !p.IsSetSuccess() {
		return ListDirectoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListDirectoryResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.ListDirectoryResp)
}

func (p *ListDirectoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListDirectoryResult) GetResult() interface{} {
	return p.Success
}

func searchFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.SearchFilesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).SearchFiles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchFilesArgs:
		success, err := handler.(file.FileService).SearchFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchFilesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchFilesArgs() interface{} {
	return &SearchFilesArgs{}
}

func newSearchFilesResult() interface{} {
	return &SearchFilesResult{}
}

type SearchFilesArgs struct {
	Req *file.SearchFilesReq
}

func (p *SearchFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchFilesArgs) Unmarshal(in []byte) error {
	msg := new(file.SearchFilesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchFilesArgs_Req_DEFAULT *file.SearchFilesReq

func (p *SearchFilesArgs) GetReq() *file.SearchFilesReq {
	if !p.IsSetReq() {
		return SearchFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchFilesResult struct {
	Success *file.SearchFilesResp
}

var SearchFilesResult_Success_DEFAULT *file.SearchFilesResp

func (p *SearchFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchFilesResult) Unmarshal(in []byte) error {
	msg := new(file.SearchFilesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchFilesResult) GetSuccess() *file.SearchFilesResp {
	if !p.IsSetSuccess() {
		return SearchFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.SearchFilesResp)
}

func (p *SearchFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchFilesResult) GetResult() interface{} {
	return p.Success
}

func buildSharedUrlHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).BuildSharedUrl(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *BuildSharedUrlArgs:
		success, err := handler.(file.FileService).BuildSharedUrl(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*BuildSharedUrlResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newBuildSharedUrlArgs() interface{} {
	return &BuildSharedUrlArgs{}
}

func newBuildSharedUrlResult() interface{} {
	return &BuildSharedUrlResult{}
}

type BuildSharedUrlArgs struct {
	Req *file.FileReq
}

func (p *BuildSharedUrlArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *BuildSharedUrlArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BuildSharedUrlArgs_Req_DEFAULT *file.FileReq

func (p *BuildSharedUrlArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return BuildSharedUrlArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BuildSharedUrlArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *BuildSharedUrlArgs) GetFirstArgument() interface{} {
	return p.Req
}

type BuildSharedUrlResult struct {
	Success *file.BuildSharedUrlResp
}

var BuildSharedUrlResult_Success_DEFAULT *file.BuildSharedUrlResp

func (p *BuildSharedUrlResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *BuildSharedUrlResult) Unmarshal(in []byte) error {
	msg := new(file.BuildSharedUrlResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BuildSharedUrlResult) GetSuccess() *file.BuildSharedUrlResp {
	if !p.IsSetSuccess() {
		return BuildSharedUrlResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BuildSharedUrlResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.BuildSharedUrlResp)
}

func (p *BuildSharedUrlResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BuildSharedUrlResult) GetResult() interface{} {
	return p.Success
}

func getPreviewUrlHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetPreviewUrl(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetPreviewUrlArgs:
		success, err := handler.(file.FileService).GetPreviewUrl(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPreviewUrlResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetPreviewUrlArgs() interface{} {
	return &GetPreviewUrlArgs{}
}

func newGetPreviewUrlResult() interface{} {
	return &GetPreviewUrlResult{}
}

type GetPreviewUrlArgs struct {
	Req *file.FileReq
}

func (p *GetPreviewUrlArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPreviewUrlArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPreviewUrlArgs_Req_DEFAULT *file.FileReq

func (p *GetPreviewUrlArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetPreviewUrlArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPreviewUrlArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPreviewUrlArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPreviewUrlResult struct {
	Success *file.PreviewResp
}

var GetPreviewUrlResult_Success_DEFAULT *file.PreviewResp

func (p *GetPreviewUrlResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPreviewUrlResult) Unmarshal(in []byte) error {
	msg := new(file.PreviewResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPreviewUrlResult) GetSuccess() *file.PreviewResp {
	if !p.IsSetSuccess() {
		return GetPreviewUrlResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPreviewUrlResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.PreviewResp)
}

func (p *GetPreviewUrlResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPreviewUrlResult) GetResult() interface{} {
	return p.Success
}

func getTranscodeStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetTranscodeStatus(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetTranscodeStatusArgs:
		success, err := handler.(file.FileService).GetTranscodeStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetTranscodeStatusResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetTranscodeStatusArgs() interface{} {
	return &GetTranscodeStatusArgs{}
}

func newGetTranscodeStatusResult() interface{} {
	return &GetTranscodeStatusResult{}
}

type GetTranscodeStatusArgs struct {
	Req *file.FileReq
}

func (p *GetTranscodeStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetTranscodeStatusArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetTranscodeStatusArgs_Req_DEFAULT *file.FileReq

func (p *GetTranscodeStatusArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetTranscodeStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetTranscodeStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTranscodeStatusArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetTranscodeStatusResult struct {
	Success *file.TranscodeStatusResp
}

var GetTranscodeStatusResult_Success_DEFAULT *file.TranscodeStatusResp

func (p *GetTranscodeStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetTranscodeStatusResult) Unmarshal(in []byte) error {
	msg := new(file.TranscodeStatusResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetTranscodeStatusResult) GetSuccess() *file.TranscodeStatusResp {
	if !p.IsSetSuccess() {
		return GetTranscodeStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetTranscodeStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.TranscodeStatusResp)
}

func (p *GetTranscodeStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTranscodeStatusResult) GetResult() interface{} {
	return p.Success
}

func generateDocumentPreviewHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GenerateDocumentPreview(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GenerateDocumentPreviewArgs:
		success, err := handler.(file.FileService).GenerateDocumentPreview(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GenerateDocumentPreviewResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGenerateDocumentPreviewArgs() interface{} {
	return &GenerateDocumentPreviewArgs{}
}

func newGenerateDocumentPreviewResult() interface{} {
	return &GenerateDocumentPreviewResult{}
}

type GenerateDocumentPreviewArgs struct {
	Req *file.FileReq
}

func (p *GenerateDocumentPreviewArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GenerateDocumentPreviewArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GenerateDocumentPreviewArgs_Req_DEFAULT *file.FileReq

func (p *GenerateDocumentPreviewArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GenerateDocumentPreviewArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GenerateDocumentPreviewArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GenerateDocumentPreviewArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GenerateDocumentPreviewResult struct {
	Success *file.PreviewResp
}

var GenerateDocumentPreviewResult_Success_DEFAULT *file.PreviewResp

func (p *GenerateDocumentPreviewResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GenerateDocumentPreviewResult) Unmarshal(in []byte) error {
	msg := new(file.PreviewResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GenerateDocumentPreviewResult) GetSuccess() *file.PreviewResp {
	if !p.IsSetSuccess() {
		return GenerateDocumentPreviewResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GenerateDocumentPreviewResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.PreviewResp)
}

func (p *GenerateDocumentPreviewResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GenerateDocumentPreviewResult) GetResult() interface{} {
	return p.Success
}

func cleanTrashHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CleanTrashReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CleanTrash(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CleanTrashArgs:
		success, err := handler.(file.FileService).CleanTrash(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CleanTrashResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCleanTrashArgs() interface{} {
	return &CleanTrashArgs{}
}

func newCleanTrashResult() interface{} {
	return &CleanTrashResult{}
}

type CleanTrashArgs struct {
	Req *file.CleanTrashReq
}

func (p *CleanTrashArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CleanTrashArgs) Unmarshal(in []byte) error {
	msg := new(file.CleanTrashReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CleanTrashArgs_Req_DEFAULT *file.CleanTrashReq

func (p *CleanTrashArgs) GetReq() *file.CleanTrashReq {
	if !p.IsSetReq() {
		return CleanTrashArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CleanTrashArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CleanTrashArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CleanTrashResult struct {
	Success *file.CleanTrashResp
}

var CleanTrashResult_Success_DEFAULT *file.CleanTrashResp

func (p *CleanTrashResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CleanTrashResult) Unmarshal(in []byte) error {
	msg := new(file.CleanTrashResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CleanTrashResult) GetSuccess() *file.CleanTrashResp {
	if !p.IsSetSuccess() {
		return CleanTrashResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CleanTrashResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.CleanTrashResp)
}

func (p *CleanTrashResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CleanTrashResult) GetResult() interface{} {
	return p.Success
}

func getStorageQuotaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.StorageQuotaReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetStorageQuota(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetStorageQuotaArgs:
		success, err := handler.(file.FileService).GetStorageQuota(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStorageQuotaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetStorageQuotaArgs() interface{} {
	return &GetStorageQuotaArgs{}
}

func newGetStorageQuotaResult() interface{} {
	return &GetStorageQuotaResult{}
}

type GetStorageQuotaArgs struct {
	Req *file.StorageQuotaReq
}

func (p *GetStorageQuotaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetStorageQuotaArgs) Unmarshal(in []byte) error {
	msg := new(file.StorageQuotaReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStorageQuotaArgs_Req_DEFAULT *file.StorageQuotaReq

func (p *GetStorageQuotaArgs) GetReq() *file.StorageQuotaReq {
	if !p.IsSetReq() {
		return GetStorageQuotaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStorageQuotaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetStorageQuotaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetStorageQuotaResult struct {
	Success *file.StorageQuotaResp
}

var GetStorageQuotaResult_Success_DEFAULT *file.StorageQuotaResp

func (p *GetStorageQuotaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetStorageQuotaResult) Unmarshal(in []byte) error {
	msg := new(file.StorageQuotaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStorageQuotaResult) GetSuccess() *file.StorageQuotaResp {
	if !p.IsSetSuccess() {
		return GetStorageQuotaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStorageQuotaResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.StorageQuotaResp)
}

func (p *GetStorageQuotaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetStorageQuotaResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) InitUpload(ctx context.Context, Req *file.InitUploadReq) (r *file.InitUploadResp, err error) {
	var _args InitUploadArgs
	_args.Req = Req
	var _result InitUploadResult
	if err = p.c.Call(ctx, "InitUpload", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadChunk(ctx context.Context, Req *file.UploadChunkReq) (r *file.UploadChunkResp, err error) {
	var _args UploadChunkArgs
	_args.Req = Req
	var _result UploadChunkResult
	if err = p.c.Call(ctx, "UploadChunk", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadVerify(ctx context.Context, Req *file.UploadVerifyReq) (r *file.UploadVerifyResp, err error) {
	var _args UploadVerifyArgs
	_args.Req = Req
	var _result UploadVerifyResult
	if err = p.c.Call(ctx, "UploadVerify", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DirectUpload(ctx context.Context, Req *file.DirectUploadReq) (r *file.DirectUploadResp, err error) {
	var _args DirectUploadArgs
	_args.Req = Req
	var _result DirectUploadResult
	if err = p.c.Call(ctx, "DirectUpload", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PreDownLoad(ctx context.Context, Req *file.PreDownLoadReq) (r *file.PreDownloadResp, err error) {
	var _args PreDownLoadArgs
	_args.Req = Req
	var _result PreDownLoadResult
	if err = p.c.Call(ctx, "PreDownLoad", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Download(ctx context.Context, Req *file.DownloadReq) (r *file.DownloadResp, err error) {
	var _args DownloadArgs
	_args.Req = Req
	var _result DownloadResult
	if err = p.c.Call(ctx, "Download", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateFolder(ctx context.Context, Req *file.CreateFolderReq) (r *file.FileAliasItem, err error) {
	var _args CreateFolderArgs
	_args.Req = Req
	var _result CreateFolderResult
	if err = p.c.Call(ctx, "CreateFolder", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RenameFile(ctx context.Context, Req *file.RenameFileReq) (r *file.FileAliasItem, err error) {
	var _args RenameFileArgs
	_args.Req = Req
	var _result RenameFileResult
	if err = p.c.Call(ctx, "RenameFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) TransferSave(ctx context.Context, Req *file.TransferSaveReq) (r *file.TransferSaveResp, err error) {
	var _args TransferSaveArgs
	_args.Req = Req
	var _result TransferSaveResult
	if err = p.c.Call(ctx, "TransferSave", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MoveFile(ctx context.Context, Req *file.MoveFileReq) (r *file.FileAliasItem, err error) {
	var _args MoveFileArgs
	_args.Req = Req
	var _result MoveFileResult
	if err = p.c.Call(ctx, "MoveFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) TrashFile(ctx context.Context, Req *file.FileReq) (r *file.FileAliasItem, err error) {
	var _args TrashFileArgs
	_args.Req = Req
	var _result TrashFileResult
	if err = p.c.Call(ctx, "TrashFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteFile(ctx context.Context, Req *file.FileReq) (r *file.FileAliasItem, err error) {
	var _args DeleteFileArgs
	_args.Req = Req
	var _result DeleteFileResult
	if err = p.c.Call(ctx, "DeleteFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RestoreFile(ctx context.Context, Req *file.FileReq) (r *file.FileAliasItem, err error) {
	var _args RestoreFileArgs
	_args.Req = Req
	var _result RestoreFileResult
	if err = p.c.Call(ctx, "RestoreFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileMeta(ctx context.Context, Req *file.FileReq) (r *file.FileMetaResp, err error) {
	var _args GetFileMetaArgs
	_args.Req = Req
	var _result GetFileMetaResult
	if err = p.c.Call(ctx, "GetFileMeta", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListDirectory(ctx context.Context, Req *file.ListDirectoryReq) (r *file.ListDirectoryResp, err error) {
	var _args ListDirectoryArgs
	_args.Req = Req
	var _result ListDirectoryResult
	if err = p.c.Call(ctx, "ListDirectory", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchFiles(ctx context.Context, Req *file.SearchFilesReq) (r *file.SearchFilesResp, err error) {
	var _args SearchFilesArgs
	_args.Req = Req
	var _result SearchFilesResult
	if err = p.c.Call(ctx, "SearchFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) BuildSharedUrl(ctx context.Context, Req *file.FileReq) (r *file.BuildSharedUrlResp, err error) {
	var _args BuildSharedUrlArgs
	_args.Req = Req
	var _result BuildSharedUrlResult
	if err = p.c.Call(ctx, "BuildSharedUrl", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPreviewUrl(ctx context.Context, Req *file.FileReq) (r *file.PreviewResp, err error) {
	var _args GetPreviewUrlArgs
	_args.Req = Req
	var _result GetPreviewUrlResult
	if err = p.c.Call(ctx, "GetPreviewUrl", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetTranscodeStatus(ctx context.Context, Req *file.FileReq) (r *file.TranscodeStatusResp, err error) {
	var _args GetTranscodeStatusArgs
	_args.Req = Req
	var _result GetTranscodeStatusResult
	if err = p.c.Call(ctx, "GetTranscodeStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GenerateDocumentPreview(ctx context.Context, Req *file.FileReq) (r *file.PreviewResp, err error) {
	var _args GenerateDocumentPreviewArgs
	_args.Req = Req
	var _result GenerateDocumentPreviewResult
	if err = p.c.Call(ctx, "GenerateDocumentPreview", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CleanTrash(ctx context.Context, Req *file.CleanTrashReq) (r *file.CleanTrashResp, err error) {
	var _args CleanTrashArgs
	_args.Req = Req
	var _result CleanTrashResult
	if err = p.c.Call(ctx, "CleanTrash", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStorageQuota(ctx context.Context, Req *file.StorageQuotaReq) (r *file.StorageQuotaResp, err error) {
	var _args GetStorageQuotaArgs
	_args.Req = Req
	var _result GetStorageQuotaResult
	if err = p.c.Call(ctx, "GetStorageQuota", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
