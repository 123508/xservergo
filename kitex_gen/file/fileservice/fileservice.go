// Code generated by Kitex v0.14.1. DO NOT EDIT.

package fileservice

import (
	"context"
	"errors"
	file "github.com/123508/xservergo/kitex_gen/file"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"InitUpload": kitex.NewMethodInfo(
		initUploadHandler,
		newInitUploadArgs,
		newInitUploadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UploadChunk": kitex.NewMethodInfo(
		uploadChunkHandler,
		newUploadChunkArgs,
		newUploadChunkResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UploadVerify": kitex.NewMethodInfo(
		uploadVerifyHandler,
		newUploadVerifyArgs,
		newUploadVerifyResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DirectUpload": kitex.NewMethodInfo(
		directUploadHandler,
		newDirectUploadArgs,
		newDirectUploadResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"TransferSave": kitex.NewMethodInfo(
		transferSaveHandler,
		newTransferSaveArgs,
		newTransferSaveResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DownloadFile": kitex.NewMethodInfo(
		downloadFileHandler,
		newDownloadFileArgs,
		newDownloadFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CreateFolder": kitex.NewMethodInfo(
		createFolderHandler,
		newCreateFolderArgs,
		newCreateFolderResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RenameFile": kitex.NewMethodInfo(
		renameFileHandler,
		newRenameFileArgs,
		newRenameFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"MoveFile": kitex.NewMethodInfo(
		moveFileHandler,
		newMoveFileArgs,
		newMoveFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CopyFile": kitex.NewMethodInfo(
		copyFileHandler,
		newCopyFileArgs,
		newCopyFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateFilePublic": kitex.NewMethodInfo(
		updateFilePublicHandler,
		newUpdateFilePublicArgs,
		newUpdateFilePublicResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"TrashFile": kitex.NewMethodInfo(
		trashFileHandler,
		newTrashFileArgs,
		newTrashFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteFilePermanently": kitex.NewMethodInfo(
		deleteFilePermanentlyHandler,
		newDeleteFilePermanentlyArgs,
		newDeleteFilePermanentlyResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"RestoreFile": kitex.NewMethodInfo(
		restoreFileHandler,
		newRestoreFileArgs,
		newRestoreFileResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetTrashedFiles": kitex.NewMethodInfo(
		getTrashedFilesHandler,
		newGetTrashedFilesArgs,
		newGetTrashedFilesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetFileMeta": kitex.NewMethodInfo(
		getFileMetaHandler,
		newGetFileMetaArgs,
		newGetFileMetaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListDirectory": kitex.NewMethodInfo(
		listDirectoryHandler,
		newListDirectoryArgs,
		newListDirectoryResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchFiles": kitex.NewMethodInfo(
		searchFilesHandler,
		newSearchFilesArgs,
		newSearchFilesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetPreviewUrl": kitex.NewMethodInfo(
		getPreviewUrlHandler,
		newGetPreviewUrlArgs,
		newGetPreviewUrlResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetTranscodeStatus": kitex.NewMethodInfo(
		getTranscodeStatusHandler,
		newGetTranscodeStatusArgs,
		newGetTranscodeStatusResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GenerateDocumentPreview": kitex.NewMethodInfo(
		generateDocumentPreviewHandler,
		newGenerateDocumentPreviewArgs,
		newGenerateDocumentPreviewResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CleanExpiredTrash": kitex.NewMethodInfo(
		cleanExpiredTrashHandler,
		newCleanExpiredTrashArgs,
		newCleanExpiredTrashResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetStorageQuota": kitex.NewMethodInfo(
		getStorageQuotaHandler,
		newGetStorageQuotaArgs,
		newGetStorageQuotaResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeduplicateFiles": kitex.NewMethodInfo(
		deduplicateFilesHandler,
		newDeduplicateFilesArgs,
		newDeduplicateFilesResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	fileServiceServiceInfo                = NewServiceInfo()
	fileServiceServiceInfoForClient       = NewServiceInfoForClient()
	fileServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return fileServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return fileServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "FileService"
	handlerType := (*file.FileService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "file",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func initUploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.InitUploadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).InitUpload(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *InitUploadArgs:
		success, err := handler.(file.FileService).InitUpload(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*InitUploadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newInitUploadArgs() interface{} {
	return &InitUploadArgs{}
}

func newInitUploadResult() interface{} {
	return &InitUploadResult{}
}

type InitUploadArgs struct {
	Req *file.InitUploadReq
}

func (p *InitUploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *InitUploadArgs) Unmarshal(in []byte) error {
	msg := new(file.InitUploadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var InitUploadArgs_Req_DEFAULT *file.InitUploadReq

func (p *InitUploadArgs) GetReq() *file.InitUploadReq {
	if !p.IsSetReq() {
		return InitUploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *InitUploadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *InitUploadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type InitUploadResult struct {
	Success *file.InitUploadResp
}

var InitUploadResult_Success_DEFAULT *file.InitUploadResp

func (p *InitUploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *InitUploadResult) Unmarshal(in []byte) error {
	msg := new(file.InitUploadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *InitUploadResult) GetSuccess() *file.InitUploadResp {
	if !p.IsSetSuccess() {
		return InitUploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *InitUploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.InitUploadResp)
}

func (p *InitUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *InitUploadResult) GetResult() interface{} {
	return p.Success
}

func uploadChunkHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UploadChunkReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).UploadChunk(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UploadChunkArgs:
		success, err := handler.(file.FileService).UploadChunk(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadChunkResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUploadChunkArgs() interface{} {
	return &UploadChunkArgs{}
}

func newUploadChunkResult() interface{} {
	return &UploadChunkResult{}
}

type UploadChunkArgs struct {
	Req *file.UploadChunkReq
}

func (p *UploadChunkArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UploadChunkArgs) Unmarshal(in []byte) error {
	msg := new(file.UploadChunkReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadChunkArgs_Req_DEFAULT *file.UploadChunkReq

func (p *UploadChunkArgs) GetReq() *file.UploadChunkReq {
	if !p.IsSetReq() {
		return UploadChunkArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadChunkArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UploadChunkArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UploadChunkResult struct {
	Success *file.UploadChunkResp
}

var UploadChunkResult_Success_DEFAULT *file.UploadChunkResp

func (p *UploadChunkResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UploadChunkResult) Unmarshal(in []byte) error {
	msg := new(file.UploadChunkResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadChunkResult) GetSuccess() *file.UploadChunkResp {
	if !p.IsSetSuccess() {
		return UploadChunkResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadChunkResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.UploadChunkResp)
}

func (p *UploadChunkResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UploadChunkResult) GetResult() interface{} {
	return p.Success
}

func uploadVerifyHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UploadVerifyReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).UploadVerify(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UploadVerifyArgs:
		success, err := handler.(file.FileService).UploadVerify(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UploadVerifyResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUploadVerifyArgs() interface{} {
	return &UploadVerifyArgs{}
}

func newUploadVerifyResult() interface{} {
	return &UploadVerifyResult{}
}

type UploadVerifyArgs struct {
	Req *file.UploadVerifyReq
}

func (p *UploadVerifyArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UploadVerifyArgs) Unmarshal(in []byte) error {
	msg := new(file.UploadVerifyReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadVerifyArgs_Req_DEFAULT *file.UploadVerifyReq

func (p *UploadVerifyArgs) GetReq() *file.UploadVerifyReq {
	if !p.IsSetReq() {
		return UploadVerifyArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadVerifyArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UploadVerifyArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UploadVerifyResult struct {
	Success *file.UploadVerifyResp
}

var UploadVerifyResult_Success_DEFAULT *file.UploadVerifyResp

func (p *UploadVerifyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UploadVerifyResult) Unmarshal(in []byte) error {
	msg := new(file.UploadVerifyResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadVerifyResult) GetSuccess() *file.UploadVerifyResp {
	if !p.IsSetSuccess() {
		return UploadVerifyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadVerifyResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.UploadVerifyResp)
}

func (p *UploadVerifyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UploadVerifyResult) GetResult() interface{} {
	return p.Success
}

func directUploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.DirectUploadReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DirectUpload(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DirectUploadArgs:
		success, err := handler.(file.FileService).DirectUpload(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DirectUploadResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDirectUploadArgs() interface{} {
	return &DirectUploadArgs{}
}

func newDirectUploadResult() interface{} {
	return &DirectUploadResult{}
}

type DirectUploadArgs struct {
	Req *file.DirectUploadReq
}

func (p *DirectUploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DirectUploadArgs) Unmarshal(in []byte) error {
	msg := new(file.DirectUploadReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DirectUploadArgs_Req_DEFAULT *file.DirectUploadReq

func (p *DirectUploadArgs) GetReq() *file.DirectUploadReq {
	if !p.IsSetReq() {
		return DirectUploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DirectUploadArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DirectUploadArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DirectUploadResult struct {
	Success *file.DirectUploadResp
}

var DirectUploadResult_Success_DEFAULT *file.DirectUploadResp

func (p *DirectUploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DirectUploadResult) Unmarshal(in []byte) error {
	msg := new(file.DirectUploadResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DirectUploadResult) GetSuccess() *file.DirectUploadResp {
	if !p.IsSetSuccess() {
		return DirectUploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DirectUploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.DirectUploadResp)
}

func (p *DirectUploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DirectUploadResult) GetResult() interface{} {
	return p.Success
}

func transferSaveHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.TransferSaveReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).TransferSave(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TransferSaveArgs:
		success, err := handler.(file.FileService).TransferSave(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TransferSaveResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTransferSaveArgs() interface{} {
	return &TransferSaveArgs{}
}

func newTransferSaveResult() interface{} {
	return &TransferSaveResult{}
}

type TransferSaveArgs struct {
	Req *file.TransferSaveReq
}

func (p *TransferSaveArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TransferSaveArgs) Unmarshal(in []byte) error {
	msg := new(file.TransferSaveReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TransferSaveArgs_Req_DEFAULT *file.TransferSaveReq

func (p *TransferSaveArgs) GetReq() *file.TransferSaveReq {
	if !p.IsSetReq() {
		return TransferSaveArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TransferSaveArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TransferSaveArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TransferSaveResult struct {
	Success *file.TransferSaveResp
}

var TransferSaveResult_Success_DEFAULT *file.TransferSaveResp

func (p *TransferSaveResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TransferSaveResult) Unmarshal(in []byte) error {
	msg := new(file.TransferSaveResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TransferSaveResult) GetSuccess() *file.TransferSaveResp {
	if !p.IsSetSuccess() {
		return TransferSaveResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TransferSaveResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.TransferSaveResp)
}

func (p *TransferSaveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TransferSaveResult) GetResult() interface{} {
	return p.Success
}

func downloadFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.DownloadFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DownloadFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DownloadFileArgs:
		success, err := handler.(file.FileService).DownloadFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DownloadFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDownloadFileArgs() interface{} {
	return &DownloadFileArgs{}
}

func newDownloadFileResult() interface{} {
	return &DownloadFileResult{}
}

type DownloadFileArgs struct {
	Req *file.DownloadFileReq
}

func (p *DownloadFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DownloadFileArgs) Unmarshal(in []byte) error {
	msg := new(file.DownloadFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DownloadFileArgs_Req_DEFAULT *file.DownloadFileReq

func (p *DownloadFileArgs) GetReq() *file.DownloadFileReq {
	if !p.IsSetReq() {
		return DownloadFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DownloadFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DownloadFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DownloadFileResult struct {
	Success *file.DownloadFileResp
}

var DownloadFileResult_Success_DEFAULT *file.DownloadFileResp

func (p *DownloadFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DownloadFileResult) Unmarshal(in []byte) error {
	msg := new(file.DownloadFileResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DownloadFileResult) GetSuccess() *file.DownloadFileResp {
	if !p.IsSetSuccess() {
		return DownloadFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DownloadFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.DownloadFileResp)
}

func (p *DownloadFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DownloadFileResult) GetResult() interface{} {
	return p.Success
}

func createFolderHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CreateFolderReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CreateFolder(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CreateFolderArgs:
		success, err := handler.(file.FileService).CreateFolder(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateFolderResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCreateFolderArgs() interface{} {
	return &CreateFolderArgs{}
}

func newCreateFolderResult() interface{} {
	return &CreateFolderResult{}
}

type CreateFolderArgs struct {
	Req *file.CreateFolderReq
}

func (p *CreateFolderArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CreateFolderArgs) Unmarshal(in []byte) error {
	msg := new(file.CreateFolderReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateFolderArgs_Req_DEFAULT *file.CreateFolderReq

func (p *CreateFolderArgs) GetReq() *file.CreateFolderReq {
	if !p.IsSetReq() {
		return CreateFolderArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateFolderArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CreateFolderArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CreateFolderResult struct {
	Success *file.FileMeta
}

var CreateFolderResult_Success_DEFAULT *file.FileMeta

func (p *CreateFolderResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CreateFolderResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateFolderResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return CreateFolderResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateFolderResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *CreateFolderResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CreateFolderResult) GetResult() interface{} {
	return p.Success
}

func renameFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.RenameFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).RenameFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RenameFileArgs:
		success, err := handler.(file.FileService).RenameFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RenameFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRenameFileArgs() interface{} {
	return &RenameFileArgs{}
}

func newRenameFileResult() interface{} {
	return &RenameFileResult{}
}

type RenameFileArgs struct {
	Req *file.RenameFileReq
}

func (p *RenameFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RenameFileArgs) Unmarshal(in []byte) error {
	msg := new(file.RenameFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RenameFileArgs_Req_DEFAULT *file.RenameFileReq

func (p *RenameFileArgs) GetReq() *file.RenameFileReq {
	if !p.IsSetReq() {
		return RenameFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RenameFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RenameFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RenameFileResult struct {
	Success *file.FileMeta
}

var RenameFileResult_Success_DEFAULT *file.FileMeta

func (p *RenameFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RenameFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RenameFileResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return RenameFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RenameFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *RenameFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RenameFileResult) GetResult() interface{} {
	return p.Success
}

func moveFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.MoveFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).MoveFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *MoveFileArgs:
		success, err := handler.(file.FileService).MoveFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MoveFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newMoveFileArgs() interface{} {
	return &MoveFileArgs{}
}

func newMoveFileResult() interface{} {
	return &MoveFileResult{}
}

type MoveFileArgs struct {
	Req *file.MoveFileReq
}

func (p *MoveFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *MoveFileArgs) Unmarshal(in []byte) error {
	msg := new(file.MoveFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MoveFileArgs_Req_DEFAULT *file.MoveFileReq

func (p *MoveFileArgs) GetReq() *file.MoveFileReq {
	if !p.IsSetReq() {
		return MoveFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MoveFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *MoveFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type MoveFileResult struct {
	Success *file.FileMeta
}

var MoveFileResult_Success_DEFAULT *file.FileMeta

func (p *MoveFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *MoveFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MoveFileResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return MoveFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MoveFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *MoveFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MoveFileResult) GetResult() interface{} {
	return p.Success
}

func copyFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CopyFileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CopyFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CopyFileArgs:
		success, err := handler.(file.FileService).CopyFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CopyFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCopyFileArgs() interface{} {
	return &CopyFileArgs{}
}

func newCopyFileResult() interface{} {
	return &CopyFileResult{}
}

type CopyFileArgs struct {
	Req *file.CopyFileReq
}

func (p *CopyFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CopyFileArgs) Unmarshal(in []byte) error {
	msg := new(file.CopyFileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CopyFileArgs_Req_DEFAULT *file.CopyFileReq

func (p *CopyFileArgs) GetReq() *file.CopyFileReq {
	if !p.IsSetReq() {
		return CopyFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CopyFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CopyFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CopyFileResult struct {
	Success *file.FileMeta
}

var CopyFileResult_Success_DEFAULT *file.FileMeta

func (p *CopyFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CopyFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CopyFileResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return CopyFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CopyFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *CopyFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CopyFileResult) GetResult() interface{} {
	return p.Success
}

func updateFilePublicHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UpdateFilePublicReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).UpdateFilePublic(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateFilePublicArgs:
		success, err := handler.(file.FileService).UpdateFilePublic(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateFilePublicResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateFilePublicArgs() interface{} {
	return &UpdateFilePublicArgs{}
}

func newUpdateFilePublicResult() interface{} {
	return &UpdateFilePublicResult{}
}

type UpdateFilePublicArgs struct {
	Req *file.UpdateFilePublicReq
}

func (p *UpdateFilePublicArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateFilePublicArgs) Unmarshal(in []byte) error {
	msg := new(file.UpdateFilePublicReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateFilePublicArgs_Req_DEFAULT *file.UpdateFilePublicReq

func (p *UpdateFilePublicArgs) GetReq() *file.UpdateFilePublicReq {
	if !p.IsSetReq() {
		return UpdateFilePublicArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateFilePublicArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateFilePublicArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateFilePublicResult struct {
	Success *file.FileMeta
}

var UpdateFilePublicResult_Success_DEFAULT *file.FileMeta

func (p *UpdateFilePublicResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateFilePublicResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateFilePublicResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return UpdateFilePublicResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateFilePublicResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *UpdateFilePublicResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateFilePublicResult) GetResult() interface{} {
	return p.Success
}

func trashFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).TrashFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *TrashFileArgs:
		success, err := handler.(file.FileService).TrashFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*TrashFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newTrashFileArgs() interface{} {
	return &TrashFileArgs{}
}

func newTrashFileResult() interface{} {
	return &TrashFileResult{}
}

type TrashFileArgs struct {
	Req *file.FileReq
}

func (p *TrashFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *TrashFileArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TrashFileArgs_Req_DEFAULT *file.FileReq

func (p *TrashFileArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return TrashFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TrashFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TrashFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type TrashFileResult struct {
	Success *file.FileMeta
}

var TrashFileResult_Success_DEFAULT *file.FileMeta

func (p *TrashFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *TrashFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TrashFileResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return TrashFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TrashFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *TrashFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TrashFileResult) GetResult() interface{} {
	return p.Success
}

func deleteFilePermanentlyHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DeleteFilePermanently(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteFilePermanentlyArgs:
		success, err := handler.(file.FileService).DeleteFilePermanently(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteFilePermanentlyResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteFilePermanentlyArgs() interface{} {
	return &DeleteFilePermanentlyArgs{}
}

func newDeleteFilePermanentlyResult() interface{} {
	return &DeleteFilePermanentlyResult{}
}

type DeleteFilePermanentlyArgs struct {
	Req *file.FileReq
}

func (p *DeleteFilePermanentlyArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteFilePermanentlyArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteFilePermanentlyArgs_Req_DEFAULT *file.FileReq

func (p *DeleteFilePermanentlyArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return DeleteFilePermanentlyArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteFilePermanentlyArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteFilePermanentlyArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteFilePermanentlyResult struct {
	Success *file.Empty
}

var DeleteFilePermanentlyResult_Success_DEFAULT *file.Empty

func (p *DeleteFilePermanentlyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteFilePermanentlyResult) Unmarshal(in []byte) error {
	msg := new(file.Empty)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteFilePermanentlyResult) GetSuccess() *file.Empty {
	if !p.IsSetSuccess() {
		return DeleteFilePermanentlyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteFilePermanentlyResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.Empty)
}

func (p *DeleteFilePermanentlyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteFilePermanentlyResult) GetResult() interface{} {
	return p.Success
}

func restoreFileHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).RestoreFile(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RestoreFileArgs:
		success, err := handler.(file.FileService).RestoreFile(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RestoreFileResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRestoreFileArgs() interface{} {
	return &RestoreFileArgs{}
}

func newRestoreFileResult() interface{} {
	return &RestoreFileResult{}
}

type RestoreFileArgs struct {
	Req *file.FileReq
}

func (p *RestoreFileArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RestoreFileArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RestoreFileArgs_Req_DEFAULT *file.FileReq

func (p *RestoreFileArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return RestoreFileArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RestoreFileArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RestoreFileArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RestoreFileResult struct {
	Success *file.FileMeta
}

var RestoreFileResult_Success_DEFAULT *file.FileMeta

func (p *RestoreFileResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RestoreFileResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RestoreFileResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return RestoreFileResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RestoreFileResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *RestoreFileResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RestoreFileResult) GetResult() interface{} {
	return p.Success
}

func getTrashedFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetTrashedFiles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetTrashedFilesArgs:
		success, err := handler.(file.FileService).GetTrashedFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetTrashedFilesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetTrashedFilesArgs() interface{} {
	return &GetTrashedFilesArgs{}
}

func newGetTrashedFilesResult() interface{} {
	return &GetTrashedFilesResult{}
}

type GetTrashedFilesArgs struct {
	Req *file.UserReq
}

func (p *GetTrashedFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetTrashedFilesArgs) Unmarshal(in []byte) error {
	msg := new(file.UserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetTrashedFilesArgs_Req_DEFAULT *file.UserReq

func (p *GetTrashedFilesArgs) GetReq() *file.UserReq {
	if !p.IsSetReq() {
		return GetTrashedFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetTrashedFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTrashedFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetTrashedFilesResult struct {
	Success *file.ListDirectoryResp
}

var GetTrashedFilesResult_Success_DEFAULT *file.ListDirectoryResp

func (p *GetTrashedFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetTrashedFilesResult) Unmarshal(in []byte) error {
	msg := new(file.ListDirectoryResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetTrashedFilesResult) GetSuccess() *file.ListDirectoryResp {
	if !p.IsSetSuccess() {
		return GetTrashedFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetTrashedFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.ListDirectoryResp)
}

func (p *GetTrashedFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTrashedFilesResult) GetResult() interface{} {
	return p.Success
}

func getFileMetaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetFileMeta(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetFileMetaArgs:
		success, err := handler.(file.FileService).GetFileMeta(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetFileMetaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetFileMetaArgs() interface{} {
	return &GetFileMetaArgs{}
}

func newGetFileMetaResult() interface{} {
	return &GetFileMetaResult{}
}

type GetFileMetaArgs struct {
	Req *file.FileReq
}

func (p *GetFileMetaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetFileMetaArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetFileMetaArgs_Req_DEFAULT *file.FileReq

func (p *GetFileMetaArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetFileMetaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetFileMetaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetFileMetaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetFileMetaResult struct {
	Success *file.FileMeta
}

var GetFileMetaResult_Success_DEFAULT *file.FileMeta

func (p *GetFileMetaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetFileMetaResult) Unmarshal(in []byte) error {
	msg := new(file.FileMeta)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetFileMetaResult) GetSuccess() *file.FileMeta {
	if !p.IsSetSuccess() {
		return GetFileMetaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetFileMetaResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.FileMeta)
}

func (p *GetFileMetaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetFileMetaResult) GetResult() interface{} {
	return p.Success
}

func listDirectoryHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.ListDirectoryReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).ListDirectory(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListDirectoryArgs:
		success, err := handler.(file.FileService).ListDirectory(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListDirectoryResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListDirectoryArgs() interface{} {
	return &ListDirectoryArgs{}
}

func newListDirectoryResult() interface{} {
	return &ListDirectoryResult{}
}

type ListDirectoryArgs struct {
	Req *file.ListDirectoryReq
}

func (p *ListDirectoryArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListDirectoryArgs) Unmarshal(in []byte) error {
	msg := new(file.ListDirectoryReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListDirectoryArgs_Req_DEFAULT *file.ListDirectoryReq

func (p *ListDirectoryArgs) GetReq() *file.ListDirectoryReq {
	if !p.IsSetReq() {
		return ListDirectoryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListDirectoryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListDirectoryArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListDirectoryResult struct {
	Success *file.ListDirectoryResp
}

var ListDirectoryResult_Success_DEFAULT *file.ListDirectoryResp

func (p *ListDirectoryResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListDirectoryResult) Unmarshal(in []byte) error {
	msg := new(file.ListDirectoryResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListDirectoryResult) GetSuccess() *file.ListDirectoryResp {
	if !p.IsSetSuccess() {
		return ListDirectoryResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListDirectoryResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.ListDirectoryResp)
}

func (p *ListDirectoryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListDirectoryResult) GetResult() interface{} {
	return p.Success
}

func searchFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.SearchFilesReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).SearchFiles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchFilesArgs:
		success, err := handler.(file.FileService).SearchFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchFilesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchFilesArgs() interface{} {
	return &SearchFilesArgs{}
}

func newSearchFilesResult() interface{} {
	return &SearchFilesResult{}
}

type SearchFilesArgs struct {
	Req *file.SearchFilesReq
}

func (p *SearchFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchFilesArgs) Unmarshal(in []byte) error {
	msg := new(file.SearchFilesReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchFilesArgs_Req_DEFAULT *file.SearchFilesReq

func (p *SearchFilesArgs) GetReq() *file.SearchFilesReq {
	if !p.IsSetReq() {
		return SearchFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchFilesResult struct {
	Success *file.SearchFilesResp
}

var SearchFilesResult_Success_DEFAULT *file.SearchFilesResp

func (p *SearchFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchFilesResult) Unmarshal(in []byte) error {
	msg := new(file.SearchFilesResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchFilesResult) GetSuccess() *file.SearchFilesResp {
	if !p.IsSetSuccess() {
		return SearchFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.SearchFilesResp)
}

func (p *SearchFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchFilesResult) GetResult() interface{} {
	return p.Success
}

func getPreviewUrlHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetPreviewUrl(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetPreviewUrlArgs:
		success, err := handler.(file.FileService).GetPreviewUrl(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPreviewUrlResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetPreviewUrlArgs() interface{} {
	return &GetPreviewUrlArgs{}
}

func newGetPreviewUrlResult() interface{} {
	return &GetPreviewUrlResult{}
}

type GetPreviewUrlArgs struct {
	Req *file.FileReq
}

func (p *GetPreviewUrlArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetPreviewUrlArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPreviewUrlArgs_Req_DEFAULT *file.FileReq

func (p *GetPreviewUrlArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetPreviewUrlArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPreviewUrlArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetPreviewUrlArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetPreviewUrlResult struct {
	Success *file.PreviewResp
}

var GetPreviewUrlResult_Success_DEFAULT *file.PreviewResp

func (p *GetPreviewUrlResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetPreviewUrlResult) Unmarshal(in []byte) error {
	msg := new(file.PreviewResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPreviewUrlResult) GetSuccess() *file.PreviewResp {
	if !p.IsSetSuccess() {
		return GetPreviewUrlResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPreviewUrlResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.PreviewResp)
}

func (p *GetPreviewUrlResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPreviewUrlResult) GetResult() interface{} {
	return p.Success
}

func getTranscodeStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetTranscodeStatus(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetTranscodeStatusArgs:
		success, err := handler.(file.FileService).GetTranscodeStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetTranscodeStatusResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetTranscodeStatusArgs() interface{} {
	return &GetTranscodeStatusArgs{}
}

func newGetTranscodeStatusResult() interface{} {
	return &GetTranscodeStatusResult{}
}

type GetTranscodeStatusArgs struct {
	Req *file.FileReq
}

func (p *GetTranscodeStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetTranscodeStatusArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetTranscodeStatusArgs_Req_DEFAULT *file.FileReq

func (p *GetTranscodeStatusArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GetTranscodeStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetTranscodeStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetTranscodeStatusArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetTranscodeStatusResult struct {
	Success *file.TranscodeStatusResp
}

var GetTranscodeStatusResult_Success_DEFAULT *file.TranscodeStatusResp

func (p *GetTranscodeStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetTranscodeStatusResult) Unmarshal(in []byte) error {
	msg := new(file.TranscodeStatusResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetTranscodeStatusResult) GetSuccess() *file.TranscodeStatusResp {
	if !p.IsSetSuccess() {
		return GetTranscodeStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetTranscodeStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.TranscodeStatusResp)
}

func (p *GetTranscodeStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTranscodeStatusResult) GetResult() interface{} {
	return p.Success
}

func generateDocumentPreviewHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.FileReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GenerateDocumentPreview(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GenerateDocumentPreviewArgs:
		success, err := handler.(file.FileService).GenerateDocumentPreview(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GenerateDocumentPreviewResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGenerateDocumentPreviewArgs() interface{} {
	return &GenerateDocumentPreviewArgs{}
}

func newGenerateDocumentPreviewResult() interface{} {
	return &GenerateDocumentPreviewResult{}
}

type GenerateDocumentPreviewArgs struct {
	Req *file.FileReq
}

func (p *GenerateDocumentPreviewArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GenerateDocumentPreviewArgs) Unmarshal(in []byte) error {
	msg := new(file.FileReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GenerateDocumentPreviewArgs_Req_DEFAULT *file.FileReq

func (p *GenerateDocumentPreviewArgs) GetReq() *file.FileReq {
	if !p.IsSetReq() {
		return GenerateDocumentPreviewArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GenerateDocumentPreviewArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GenerateDocumentPreviewArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GenerateDocumentPreviewResult struct {
	Success *file.PreviewResp
}

var GenerateDocumentPreviewResult_Success_DEFAULT *file.PreviewResp

func (p *GenerateDocumentPreviewResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GenerateDocumentPreviewResult) Unmarshal(in []byte) error {
	msg := new(file.PreviewResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GenerateDocumentPreviewResult) GetSuccess() *file.PreviewResp {
	if !p.IsSetSuccess() {
		return GenerateDocumentPreviewResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GenerateDocumentPreviewResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.PreviewResp)
}

func (p *GenerateDocumentPreviewResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GenerateDocumentPreviewResult) GetResult() interface{} {
	return p.Success
}

func cleanExpiredTrashHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.CleanTrashReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).CleanExpiredTrash(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CleanExpiredTrashArgs:
		success, err := handler.(file.FileService).CleanExpiredTrash(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CleanExpiredTrashResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCleanExpiredTrashArgs() interface{} {
	return &CleanExpiredTrashArgs{}
}

func newCleanExpiredTrashResult() interface{} {
	return &CleanExpiredTrashResult{}
}

type CleanExpiredTrashArgs struct {
	Req *file.CleanTrashReq
}

func (p *CleanExpiredTrashArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CleanExpiredTrashArgs) Unmarshal(in []byte) error {
	msg := new(file.CleanTrashReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CleanExpiredTrashArgs_Req_DEFAULT *file.CleanTrashReq

func (p *CleanExpiredTrashArgs) GetReq() *file.CleanTrashReq {
	if !p.IsSetReq() {
		return CleanExpiredTrashArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CleanExpiredTrashArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CleanExpiredTrashArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CleanExpiredTrashResult struct {
	Success *file.CleanTrashResp
}

var CleanExpiredTrashResult_Success_DEFAULT *file.CleanTrashResp

func (p *CleanExpiredTrashResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CleanExpiredTrashResult) Unmarshal(in []byte) error {
	msg := new(file.CleanTrashResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CleanExpiredTrashResult) GetSuccess() *file.CleanTrashResp {
	if !p.IsSetSuccess() {
		return CleanExpiredTrashResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CleanExpiredTrashResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.CleanTrashResp)
}

func (p *CleanExpiredTrashResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CleanExpiredTrashResult) GetResult() interface{} {
	return p.Success
}

func getStorageQuotaHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).GetStorageQuota(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetStorageQuotaArgs:
		success, err := handler.(file.FileService).GetStorageQuota(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStorageQuotaResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetStorageQuotaArgs() interface{} {
	return &GetStorageQuotaArgs{}
}

func newGetStorageQuotaResult() interface{} {
	return &GetStorageQuotaResult{}
}

type GetStorageQuotaArgs struct {
	Req *file.UserReq
}

func (p *GetStorageQuotaArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetStorageQuotaArgs) Unmarshal(in []byte) error {
	msg := new(file.UserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStorageQuotaArgs_Req_DEFAULT *file.UserReq

func (p *GetStorageQuotaArgs) GetReq() *file.UserReq {
	if !p.IsSetReq() {
		return GetStorageQuotaArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStorageQuotaArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetStorageQuotaArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetStorageQuotaResult struct {
	Success *file.StorageQuotaResp
}

var GetStorageQuotaResult_Success_DEFAULT *file.StorageQuotaResp

func (p *GetStorageQuotaResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetStorageQuotaResult) Unmarshal(in []byte) error {
	msg := new(file.StorageQuotaResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStorageQuotaResult) GetSuccess() *file.StorageQuotaResp {
	if !p.IsSetSuccess() {
		return GetStorageQuotaResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStorageQuotaResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.StorageQuotaResp)
}

func (p *GetStorageQuotaResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetStorageQuotaResult) GetResult() interface{} {
	return p.Success
}

func deduplicateFilesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(file.UserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(file.FileService).DeduplicateFiles(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeduplicateFilesArgs:
		success, err := handler.(file.FileService).DeduplicateFiles(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeduplicateFilesResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeduplicateFilesArgs() interface{} {
	return &DeduplicateFilesArgs{}
}

func newDeduplicateFilesResult() interface{} {
	return &DeduplicateFilesResult{}
}

type DeduplicateFilesArgs struct {
	Req *file.UserReq
}

func (p *DeduplicateFilesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeduplicateFilesArgs) Unmarshal(in []byte) error {
	msg := new(file.UserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeduplicateFilesArgs_Req_DEFAULT *file.UserReq

func (p *DeduplicateFilesArgs) GetReq() *file.UserReq {
	if !p.IsSetReq() {
		return DeduplicateFilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeduplicateFilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeduplicateFilesArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeduplicateFilesResult struct {
	Success *file.DeduplicationResp
}

var DeduplicateFilesResult_Success_DEFAULT *file.DeduplicationResp

func (p *DeduplicateFilesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeduplicateFilesResult) Unmarshal(in []byte) error {
	msg := new(file.DeduplicationResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeduplicateFilesResult) GetSuccess() *file.DeduplicationResp {
	if !p.IsSetSuccess() {
		return DeduplicateFilesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeduplicateFilesResult) SetSuccess(x interface{}) {
	p.Success = x.(*file.DeduplicationResp)
}

func (p *DeduplicateFilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeduplicateFilesResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) InitUpload(ctx context.Context, Req *file.InitUploadReq) (r *file.InitUploadResp, err error) {
	var _args InitUploadArgs
	_args.Req = Req
	var _result InitUploadResult
	if err = p.c.Call(ctx, "InitUpload", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadChunk(ctx context.Context, Req *file.UploadChunkReq) (r *file.UploadChunkResp, err error) {
	var _args UploadChunkArgs
	_args.Req = Req
	var _result UploadChunkResult
	if err = p.c.Call(ctx, "UploadChunk", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UploadVerify(ctx context.Context, Req *file.UploadVerifyReq) (r *file.UploadVerifyResp, err error) {
	var _args UploadVerifyArgs
	_args.Req = Req
	var _result UploadVerifyResult
	if err = p.c.Call(ctx, "UploadVerify", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DirectUpload(ctx context.Context, Req *file.DirectUploadReq) (r *file.DirectUploadResp, err error) {
	var _args DirectUploadArgs
	_args.Req = Req
	var _result DirectUploadResult
	if err = p.c.Call(ctx, "DirectUpload", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) TransferSave(ctx context.Context, Req *file.TransferSaveReq) (r *file.TransferSaveResp, err error) {
	var _args TransferSaveArgs
	_args.Req = Req
	var _result TransferSaveResult
	if err = p.c.Call(ctx, "TransferSave", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DownloadFile(ctx context.Context, Req *file.DownloadFileReq) (r *file.DownloadFileResp, err error) {
	var _args DownloadFileArgs
	_args.Req = Req
	var _result DownloadFileResult
	if err = p.c.Call(ctx, "DownloadFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CreateFolder(ctx context.Context, Req *file.CreateFolderReq) (r *file.FileMeta, err error) {
	var _args CreateFolderArgs
	_args.Req = Req
	var _result CreateFolderResult
	if err = p.c.Call(ctx, "CreateFolder", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RenameFile(ctx context.Context, Req *file.RenameFileReq) (r *file.FileMeta, err error) {
	var _args RenameFileArgs
	_args.Req = Req
	var _result RenameFileResult
	if err = p.c.Call(ctx, "RenameFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MoveFile(ctx context.Context, Req *file.MoveFileReq) (r *file.FileMeta, err error) {
	var _args MoveFileArgs
	_args.Req = Req
	var _result MoveFileResult
	if err = p.c.Call(ctx, "MoveFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CopyFile(ctx context.Context, Req *file.CopyFileReq) (r *file.FileMeta, err error) {
	var _args CopyFileArgs
	_args.Req = Req
	var _result CopyFileResult
	if err = p.c.Call(ctx, "CopyFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateFilePublic(ctx context.Context, Req *file.UpdateFilePublicReq) (r *file.FileMeta, err error) {
	var _args UpdateFilePublicArgs
	_args.Req = Req
	var _result UpdateFilePublicResult
	if err = p.c.Call(ctx, "UpdateFilePublic", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) TrashFile(ctx context.Context, Req *file.FileReq) (r *file.FileMeta, err error) {
	var _args TrashFileArgs
	_args.Req = Req
	var _result TrashFileResult
	if err = p.c.Call(ctx, "TrashFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteFilePermanently(ctx context.Context, Req *file.FileReq) (r *file.Empty, err error) {
	var _args DeleteFilePermanentlyArgs
	_args.Req = Req
	var _result DeleteFilePermanentlyResult
	if err = p.c.Call(ctx, "DeleteFilePermanently", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RestoreFile(ctx context.Context, Req *file.FileReq) (r *file.FileMeta, err error) {
	var _args RestoreFileArgs
	_args.Req = Req
	var _result RestoreFileResult
	if err = p.c.Call(ctx, "RestoreFile", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetTrashedFiles(ctx context.Context, Req *file.UserReq) (r *file.ListDirectoryResp, err error) {
	var _args GetTrashedFilesArgs
	_args.Req = Req
	var _result GetTrashedFilesResult
	if err = p.c.Call(ctx, "GetTrashedFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetFileMeta(ctx context.Context, Req *file.FileReq) (r *file.FileMeta, err error) {
	var _args GetFileMetaArgs
	_args.Req = Req
	var _result GetFileMetaResult
	if err = p.c.Call(ctx, "GetFileMeta", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListDirectory(ctx context.Context, Req *file.ListDirectoryReq) (r *file.ListDirectoryResp, err error) {
	var _args ListDirectoryArgs
	_args.Req = Req
	var _result ListDirectoryResult
	if err = p.c.Call(ctx, "ListDirectory", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchFiles(ctx context.Context, Req *file.SearchFilesReq) (r *file.SearchFilesResp, err error) {
	var _args SearchFilesArgs
	_args.Req = Req
	var _result SearchFilesResult
	if err = p.c.Call(ctx, "SearchFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPreviewUrl(ctx context.Context, Req *file.FileReq) (r *file.PreviewResp, err error) {
	var _args GetPreviewUrlArgs
	_args.Req = Req
	var _result GetPreviewUrlResult
	if err = p.c.Call(ctx, "GetPreviewUrl", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetTranscodeStatus(ctx context.Context, Req *file.FileReq) (r *file.TranscodeStatusResp, err error) {
	var _args GetTranscodeStatusArgs
	_args.Req = Req
	var _result GetTranscodeStatusResult
	if err = p.c.Call(ctx, "GetTranscodeStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GenerateDocumentPreview(ctx context.Context, Req *file.FileReq) (r *file.PreviewResp, err error) {
	var _args GenerateDocumentPreviewArgs
	_args.Req = Req
	var _result GenerateDocumentPreviewResult
	if err = p.c.Call(ctx, "GenerateDocumentPreview", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CleanExpiredTrash(ctx context.Context, Req *file.CleanTrashReq) (r *file.CleanTrashResp, err error) {
	var _args CleanExpiredTrashArgs
	_args.Req = Req
	var _result CleanExpiredTrashResult
	if err = p.c.Call(ctx, "CleanExpiredTrash", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStorageQuota(ctx context.Context, Req *file.UserReq) (r *file.StorageQuotaResp, err error) {
	var _args GetStorageQuotaArgs
	_args.Req = Req
	var _result GetStorageQuotaResult
	if err = p.c.Call(ctx, "GetStorageQuota", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeduplicateFiles(ctx context.Context, Req *file.UserReq) (r *file.DeduplicationResp, err error) {
	var _args DeduplicateFilesArgs
	_args.Req = Req
	var _result DeduplicateFilesResult
	if err = p.c.Call(ctx, "DeduplicateFiles", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
