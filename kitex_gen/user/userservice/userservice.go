// Code generated by Kitex v0.14.1. DO NOT EDIT.

package userservice

import (
	"context"
	"errors"
	user "github.com/123508/xservergo/kitex_gen/user"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"Register": kitex.NewMethodInfo(
		registerHandler,
		newRegisterArgs,
		newRegisterResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"EmailLogin": kitex.NewMethodInfo(
		emailLoginHandler,
		newEmailLoginArgs,
		newEmailLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PhoneLogin": kitex.NewMethodInfo(
		phoneLoginHandler,
		newPhoneLoginArgs,
		newPhoneLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AccountLogin": kitex.NewMethodInfo(
		accountLoginHandler,
		newAccountLoginArgs,
		newAccountLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SmsLogin": kitex.NewMethodInfo(
		smsLoginHandler,
		newSmsLoginArgs,
		newSmsLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GenerateQrCode": kitex.NewMethodInfo(
		generateQrCodeHandler,
		newGenerateQrCodeArgs,
		newGenerateQrCodeResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QrCodePreLoginStatus": kitex.NewMethodInfo(
		qrCodePreLoginStatusHandler,
		newQrCodePreLoginStatusArgs,
		newQrCodePreLoginStatusResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QrCodeLoginStatus": kitex.NewMethodInfo(
		qrCodeLoginStatusHandler,
		newQrCodeLoginStatusArgs,
		newQrCodeLoginStatusResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QrPreLogin": kitex.NewMethodInfo(
		qrPreLoginHandler,
		newQrPreLoginArgs,
		newQrPreLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ConfirmQrLogin": kitex.NewMethodInfo(
		confirmQrLoginHandler,
		newConfirmQrLoginArgs,
		newConfirmQrLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CancelQrLogin": kitex.NewMethodInfo(
		cancelQrLoginHandler,
		newCancelQrLoginArgs,
		newCancelQrLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"OAuthLogin": kitex.NewMethodInfo(
		oAuthLoginHandler,
		newOAuthLoginArgs,
		newOAuthLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Logout": kitex.NewMethodInfo(
		logoutHandler,
		newLogoutArgs,
		newLogoutResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ChangePassword": kitex.NewMethodInfo(
		changePasswordHandler,
		newChangePasswordArgs,
		newChangePasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ForgotPassword": kitex.NewMethodInfo(
		forgotPasswordHandler,
		newForgotPasswordArgs,
		newForgotPasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ResetPassword": kitex.NewMethodInfo(
		resetPasswordHandler,
		newResetPasswordArgs,
		newResetPasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartBindEmail": kitex.NewMethodInfo(
		startBindEmailHandler,
		newStartBindEmailArgs,
		newStartBindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteBindEmail": kitex.NewMethodInfo(
		completeBindEmailHandler,
		newCompleteBindEmailArgs,
		newCompleteBindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartChangeEmail": kitex.NewMethodInfo(
		startChangeEmailHandler,
		newStartChangeEmailArgs,
		newStartChangeEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyNewEmail": kitex.NewMethodInfo(
		verifyNewEmailHandler,
		newVerifyNewEmailArgs,
		newVerifyNewEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteChangeEmail": kitex.NewMethodInfo(
		completeChangeEmailHandler,
		newCompleteChangeEmailArgs,
		newCompleteChangeEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartBindPhone": kitex.NewMethodInfo(
		startBindPhoneHandler,
		newStartBindPhoneArgs,
		newStartBindPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteBindPhone": kitex.NewMethodInfo(
		completeBindPhoneHandler,
		newCompleteBindPhoneArgs,
		newCompleteBindPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartChangePhone": kitex.NewMethodInfo(
		startChangePhoneHandler,
		newStartChangePhoneArgs,
		newStartChangePhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyNewPhone": kitex.NewMethodInfo(
		verifyNewPhoneHandler,
		newVerifyNewPhoneArgs,
		newVerifyNewPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteChangePhone": kitex.NewMethodInfo(
		completeChangePhoneHandler,
		newCompleteChangePhoneArgs,
		newCompleteChangePhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserInfoById": kitex.NewMethodInfo(
		getUserInfoByIdHandler,
		newGetUserInfoByIdArgs,
		newGetUserInfoByIdResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserInfoByOthers": kitex.NewMethodInfo(
		getUserInfoByOthersHandler,
		newGetUserInfoByOthersArgs,
		newGetUserInfoByOthersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUserInfo": kitex.NewMethodInfo(
		updateUserInfoHandler,
		newUpdateUserInfoArgs,
		newUpdateUserInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListUsers": kitex.NewMethodInfo(
		listUsersHandler,
		newListUsersArgs,
		newListUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchUserByNickname": kitex.NewMethodInfo(
		searchUserByNicknameHandler,
		newSearchUserByNicknameArgs,
		newSearchUserByNicknameResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartDeactivateUser": kitex.NewMethodInfo(
		startDeactivateUserHandler,
		newStartDeactivateUserArgs,
		newStartDeactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeactivateUser": kitex.NewMethodInfo(
		deactivateUserHandler,
		newDeactivateUserArgs,
		newDeactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ReactivateUser": kitex.NewMethodInfo(
		reactivateUserHandler,
		newReactivateUserArgs,
		newReactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartDeleteUser": kitex.NewMethodInfo(
		startDeleteUserHandler,
		newStartDeleteUserArgs,
		newStartDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUser": kitex.NewMethodInfo(
		deleteUserHandler,
		newDeleteUserArgs,
		newDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	userServiceServiceInfo                = NewServiceInfo()
	userServiceServiceInfoForClient       = NewServiceInfoForClient()
	userServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return userServiceServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "UserService"
	handlerType := (*user.UserService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "user",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func registerHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.RegisterReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).Register(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RegisterArgs:
		success, err := handler.(user.UserService).Register(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegisterResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRegisterArgs() interface{} {
	return &RegisterArgs{}
}

func newRegisterResult() interface{} {
	return &RegisterResult{}
}

type RegisterArgs struct {
	Req *user.RegisterReq
}

func (p *RegisterArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RegisterArgs) Unmarshal(in []byte) error {
	msg := new(user.RegisterReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegisterArgs_Req_DEFAULT *user.RegisterReq

func (p *RegisterArgs) GetReq() *user.RegisterReq {
	if !p.IsSetReq() {
		return RegisterArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegisterArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RegisterArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RegisterResult struct {
	Success *user.OperationResult
}

var RegisterResult_Success_DEFAULT *user.OperationResult

func (p *RegisterResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RegisterResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegisterResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return RegisterResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegisterResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *RegisterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RegisterResult) GetResult() interface{} {
	return p.Success
}

func emailLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.EmailLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).EmailLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *EmailLoginArgs:
		success, err := handler.(user.UserService).EmailLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*EmailLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newEmailLoginArgs() interface{} {
	return &EmailLoginArgs{}
}

func newEmailLoginResult() interface{} {
	return &EmailLoginResult{}
}

type EmailLoginArgs struct {
	Req *user.EmailLoginReq
}

func (p *EmailLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *EmailLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.EmailLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var EmailLoginArgs_Req_DEFAULT *user.EmailLoginReq

func (p *EmailLoginArgs) GetReq() *user.EmailLoginReq {
	if !p.IsSetReq() {
		return EmailLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *EmailLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *EmailLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type EmailLoginResult struct {
	Success *user.LoginResp
}

var EmailLoginResult_Success_DEFAULT *user.LoginResp

func (p *EmailLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *EmailLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *EmailLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return EmailLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *EmailLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *EmailLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EmailLoginResult) GetResult() interface{} {
	return p.Success
}

func phoneLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.PhoneLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).PhoneLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PhoneLoginArgs:
		success, err := handler.(user.UserService).PhoneLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PhoneLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPhoneLoginArgs() interface{} {
	return &PhoneLoginArgs{}
}

func newPhoneLoginResult() interface{} {
	return &PhoneLoginResult{}
}

type PhoneLoginArgs struct {
	Req *user.PhoneLoginReq
}

func (p *PhoneLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PhoneLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.PhoneLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PhoneLoginArgs_Req_DEFAULT *user.PhoneLoginReq

func (p *PhoneLoginArgs) GetReq() *user.PhoneLoginReq {
	if !p.IsSetReq() {
		return PhoneLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PhoneLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PhoneLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PhoneLoginResult struct {
	Success *user.LoginResp
}

var PhoneLoginResult_Success_DEFAULT *user.LoginResp

func (p *PhoneLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PhoneLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PhoneLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return PhoneLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PhoneLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *PhoneLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PhoneLoginResult) GetResult() interface{} {
	return p.Success
}

func accountLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.AccountLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).AccountLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AccountLoginArgs:
		success, err := handler.(user.UserService).AccountLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AccountLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAccountLoginArgs() interface{} {
	return &AccountLoginArgs{}
}

func newAccountLoginResult() interface{} {
	return &AccountLoginResult{}
}

type AccountLoginArgs struct {
	Req *user.AccountLoginReq
}

func (p *AccountLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AccountLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.AccountLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AccountLoginArgs_Req_DEFAULT *user.AccountLoginReq

func (p *AccountLoginArgs) GetReq() *user.AccountLoginReq {
	if !p.IsSetReq() {
		return AccountLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AccountLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AccountLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AccountLoginResult struct {
	Success *user.LoginResp
}

var AccountLoginResult_Success_DEFAULT *user.LoginResp

func (p *AccountLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AccountLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AccountLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return AccountLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AccountLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *AccountLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AccountLoginResult) GetResult() interface{} {
	return p.Success
}

func smsLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SmsLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SmsLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SmsLoginArgs:
		success, err := handler.(user.UserService).SmsLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SmsLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSmsLoginArgs() interface{} {
	return &SmsLoginArgs{}
}

func newSmsLoginResult() interface{} {
	return &SmsLoginResult{}
}

type SmsLoginArgs struct {
	Req *user.SmsLoginReq
}

func (p *SmsLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SmsLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.SmsLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SmsLoginArgs_Req_DEFAULT *user.SmsLoginReq

func (p *SmsLoginArgs) GetReq() *user.SmsLoginReq {
	if !p.IsSetReq() {
		return SmsLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SmsLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SmsLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SmsLoginResult struct {
	Success *user.SmsLoginResp
}

var SmsLoginResult_Success_DEFAULT *user.SmsLoginResp

func (p *SmsLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SmsLoginResult) Unmarshal(in []byte) error {
	msg := new(user.SmsLoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SmsLoginResult) GetSuccess() *user.SmsLoginResp {
	if !p.IsSetSuccess() {
		return SmsLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SmsLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SmsLoginResp)
}

func (p *SmsLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SmsLoginResult) GetResult() interface{} {
	return p.Success
}

func generateQrCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GenerateQrCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).GenerateQrCode(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GenerateQrCodeArgs:
		success, err := handler.(user.UserService).GenerateQrCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GenerateQrCodeResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGenerateQrCodeArgs() interface{} {
	return &GenerateQrCodeArgs{}
}

func newGenerateQrCodeResult() interface{} {
	return &GenerateQrCodeResult{}
}

type GenerateQrCodeArgs struct {
	Req *user.GenerateQrCodeReq
}

func (p *GenerateQrCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GenerateQrCodeArgs) Unmarshal(in []byte) error {
	msg := new(user.GenerateQrCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GenerateQrCodeArgs_Req_DEFAULT *user.GenerateQrCodeReq

func (p *GenerateQrCodeArgs) GetReq() *user.GenerateQrCodeReq {
	if !p.IsSetReq() {
		return GenerateQrCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GenerateQrCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GenerateQrCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GenerateQrCodeResult struct {
	Success *user.GenerateQrCodeResp
}

var GenerateQrCodeResult_Success_DEFAULT *user.GenerateQrCodeResp

func (p *GenerateQrCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GenerateQrCodeResult) Unmarshal(in []byte) error {
	msg := new(user.GenerateQrCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GenerateQrCodeResult) GetSuccess() *user.GenerateQrCodeResp {
	if !p.IsSetSuccess() {
		return GenerateQrCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GenerateQrCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.GenerateQrCodeResp)
}

func (p *GenerateQrCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GenerateQrCodeResult) GetResult() interface{} {
	return p.Success
}

func qrCodePreLoginStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.QrCodePreLoginStatusReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).QrCodePreLoginStatus(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QrCodePreLoginStatusArgs:
		success, err := handler.(user.UserService).QrCodePreLoginStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QrCodePreLoginStatusResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQrCodePreLoginStatusArgs() interface{} {
	return &QrCodePreLoginStatusArgs{}
}

func newQrCodePreLoginStatusResult() interface{} {
	return &QrCodePreLoginStatusResult{}
}

type QrCodePreLoginStatusArgs struct {
	Req *user.QrCodePreLoginStatusReq
}

func (p *QrCodePreLoginStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QrCodePreLoginStatusArgs) Unmarshal(in []byte) error {
	msg := new(user.QrCodePreLoginStatusReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QrCodePreLoginStatusArgs_Req_DEFAULT *user.QrCodePreLoginStatusReq

func (p *QrCodePreLoginStatusArgs) GetReq() *user.QrCodePreLoginStatusReq {
	if !p.IsSetReq() {
		return QrCodePreLoginStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QrCodePreLoginStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QrCodePreLoginStatusArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QrCodePreLoginStatusResult struct {
	Success *user.QrCodePreLoginStatusResp
}

var QrCodePreLoginStatusResult_Success_DEFAULT *user.QrCodePreLoginStatusResp

func (p *QrCodePreLoginStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QrCodePreLoginStatusResult) Unmarshal(in []byte) error {
	msg := new(user.QrCodePreLoginStatusResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QrCodePreLoginStatusResult) GetSuccess() *user.QrCodePreLoginStatusResp {
	if !p.IsSetSuccess() {
		return QrCodePreLoginStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QrCodePreLoginStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.QrCodePreLoginStatusResp)
}

func (p *QrCodePreLoginStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QrCodePreLoginStatusResult) GetResult() interface{} {
	return p.Success
}

func qrCodeLoginStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.QrCodeLoginStatusReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).QrCodeLoginStatus(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QrCodeLoginStatusArgs:
		success, err := handler.(user.UserService).QrCodeLoginStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QrCodeLoginStatusResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQrCodeLoginStatusArgs() interface{} {
	return &QrCodeLoginStatusArgs{}
}

func newQrCodeLoginStatusResult() interface{} {
	return &QrCodeLoginStatusResult{}
}

type QrCodeLoginStatusArgs struct {
	Req *user.QrCodeLoginStatusReq
}

func (p *QrCodeLoginStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QrCodeLoginStatusArgs) Unmarshal(in []byte) error {
	msg := new(user.QrCodeLoginStatusReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QrCodeLoginStatusArgs_Req_DEFAULT *user.QrCodeLoginStatusReq

func (p *QrCodeLoginStatusArgs) GetReq() *user.QrCodeLoginStatusReq {
	if !p.IsSetReq() {
		return QrCodeLoginStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QrCodeLoginStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QrCodeLoginStatusArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QrCodeLoginStatusResult struct {
	Success *user.QrCodeLoginStatusResp
}

var QrCodeLoginStatusResult_Success_DEFAULT *user.QrCodeLoginStatusResp

func (p *QrCodeLoginStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QrCodeLoginStatusResult) Unmarshal(in []byte) error {
	msg := new(user.QrCodeLoginStatusResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QrCodeLoginStatusResult) GetSuccess() *user.QrCodeLoginStatusResp {
	if !p.IsSetSuccess() {
		return QrCodeLoginStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QrCodeLoginStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.QrCodeLoginStatusResp)
}

func (p *QrCodeLoginStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QrCodeLoginStatusResult) GetResult() interface{} {
	return p.Success
}

func qrPreLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.QrPreLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).QrPreLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QrPreLoginArgs:
		success, err := handler.(user.UserService).QrPreLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QrPreLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQrPreLoginArgs() interface{} {
	return &QrPreLoginArgs{}
}

func newQrPreLoginResult() interface{} {
	return &QrPreLoginResult{}
}

type QrPreLoginArgs struct {
	Req *user.QrPreLoginReq
}

func (p *QrPreLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QrPreLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.QrPreLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QrPreLoginArgs_Req_DEFAULT *user.QrPreLoginReq

func (p *QrPreLoginArgs) GetReq() *user.QrPreLoginReq {
	if !p.IsSetReq() {
		return QrPreLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QrPreLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QrPreLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QrPreLoginResult struct {
	Success *user.QrPreLoginResp
}

var QrPreLoginResult_Success_DEFAULT *user.QrPreLoginResp

func (p *QrPreLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QrPreLoginResult) Unmarshal(in []byte) error {
	msg := new(user.QrPreLoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QrPreLoginResult) GetSuccess() *user.QrPreLoginResp {
	if !p.IsSetSuccess() {
		return QrPreLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QrPreLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.QrPreLoginResp)
}

func (p *QrPreLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QrPreLoginResult) GetResult() interface{} {
	return p.Success
}

func confirmQrLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ConfirmQrLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ConfirmQrLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ConfirmQrLoginArgs:
		success, err := handler.(user.UserService).ConfirmQrLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ConfirmQrLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newConfirmQrLoginArgs() interface{} {
	return &ConfirmQrLoginArgs{}
}

func newConfirmQrLoginResult() interface{} {
	return &ConfirmQrLoginResult{}
}

type ConfirmQrLoginArgs struct {
	Req *user.ConfirmQrLoginReq
}

func (p *ConfirmQrLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ConfirmQrLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.ConfirmQrLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ConfirmQrLoginArgs_Req_DEFAULT *user.ConfirmQrLoginReq

func (p *ConfirmQrLoginArgs) GetReq() *user.ConfirmQrLoginReq {
	if !p.IsSetReq() {
		return ConfirmQrLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ConfirmQrLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ConfirmQrLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ConfirmQrLoginResult struct {
	Success *user.Empty
}

var ConfirmQrLoginResult_Success_DEFAULT *user.Empty

func (p *ConfirmQrLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ConfirmQrLoginResult) Unmarshal(in []byte) error {
	msg := new(user.Empty)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ConfirmQrLoginResult) GetSuccess() *user.Empty {
	if !p.IsSetSuccess() {
		return ConfirmQrLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ConfirmQrLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.Empty)
}

func (p *ConfirmQrLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ConfirmQrLoginResult) GetResult() interface{} {
	return p.Success
}

func cancelQrLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CancelQrLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CancelQrLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CancelQrLoginArgs:
		success, err := handler.(user.UserService).CancelQrLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CancelQrLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCancelQrLoginArgs() interface{} {
	return &CancelQrLoginArgs{}
}

func newCancelQrLoginResult() interface{} {
	return &CancelQrLoginResult{}
}

type CancelQrLoginArgs struct {
	Req *user.CancelQrLoginReq
}

func (p *CancelQrLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CancelQrLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.CancelQrLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CancelQrLoginArgs_Req_DEFAULT *user.CancelQrLoginReq

func (p *CancelQrLoginArgs) GetReq() *user.CancelQrLoginReq {
	if !p.IsSetReq() {
		return CancelQrLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CancelQrLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CancelQrLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CancelQrLoginResult struct {
	Success *user.Empty
}

var CancelQrLoginResult_Success_DEFAULT *user.Empty

func (p *CancelQrLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CancelQrLoginResult) Unmarshal(in []byte) error {
	msg := new(user.Empty)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CancelQrLoginResult) GetSuccess() *user.Empty {
	if !p.IsSetSuccess() {
		return CancelQrLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CancelQrLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.Empty)
}

func (p *CancelQrLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CancelQrLoginResult) GetResult() interface{} {
	return p.Success
}

func oAuthLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.OAuthLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).OAuthLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *OAuthLoginArgs:
		success, err := handler.(user.UserService).OAuthLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*OAuthLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newOAuthLoginArgs() interface{} {
	return &OAuthLoginArgs{}
}

func newOAuthLoginResult() interface{} {
	return &OAuthLoginResult{}
}

type OAuthLoginArgs struct {
	Req *user.OAuthLoginReq
}

func (p *OAuthLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *OAuthLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.OAuthLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var OAuthLoginArgs_Req_DEFAULT *user.OAuthLoginReq

func (p *OAuthLoginArgs) GetReq() *user.OAuthLoginReq {
	if !p.IsSetReq() {
		return OAuthLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *OAuthLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *OAuthLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type OAuthLoginResult struct {
	Success *user.LoginResp
}

var OAuthLoginResult_Success_DEFAULT *user.LoginResp

func (p *OAuthLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *OAuthLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *OAuthLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return OAuthLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *OAuthLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *OAuthLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *OAuthLoginResult) GetResult() interface{} {
	return p.Success
}

func logoutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.LogoutReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).Logout(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LogoutArgs:
		success, err := handler.(user.UserService).Logout(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LogoutResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLogoutArgs() interface{} {
	return &LogoutArgs{}
}

func newLogoutResult() interface{} {
	return &LogoutResult{}
}

type LogoutArgs struct {
	Req *user.LogoutReq
}

func (p *LogoutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LogoutArgs) Unmarshal(in []byte) error {
	msg := new(user.LogoutReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LogoutArgs_Req_DEFAULT *user.LogoutReq

func (p *LogoutArgs) GetReq() *user.LogoutReq {
	if !p.IsSetReq() {
		return LogoutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LogoutArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LogoutArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LogoutResult struct {
	Success *user.OperationResult
}

var LogoutResult_Success_DEFAULT *user.OperationResult

func (p *LogoutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LogoutResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LogoutResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LogoutResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) GetResult() interface{} {
	return p.Success
}

func changePasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ChangePasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ChangePassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ChangePasswordArgs:
		success, err := handler.(user.UserService).ChangePassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ChangePasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newChangePasswordArgs() interface{} {
	return &ChangePasswordArgs{}
}

func newChangePasswordResult() interface{} {
	return &ChangePasswordResult{}
}

type ChangePasswordArgs struct {
	Req *user.ChangePasswordReq
}

func (p *ChangePasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ChangePasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ChangePasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ChangePasswordArgs_Req_DEFAULT *user.ChangePasswordReq

func (p *ChangePasswordArgs) GetReq() *user.ChangePasswordReq {
	if !p.IsSetReq() {
		return ChangePasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ChangePasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ChangePasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ChangePasswordResult struct {
	Success *user.OperationResult
}

var ChangePasswordResult_Success_DEFAULT *user.OperationResult

func (p *ChangePasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ChangePasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ChangePasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ChangePasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ChangePasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ChangePasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChangePasswordResult) GetResult() interface{} {
	return p.Success
}

func forgotPasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ForgotPasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ForgotPassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ForgotPasswordArgs:
		success, err := handler.(user.UserService).ForgotPassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ForgotPasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newForgotPasswordArgs() interface{} {
	return &ForgotPasswordArgs{}
}

func newForgotPasswordResult() interface{} {
	return &ForgotPasswordResult{}
}

type ForgotPasswordArgs struct {
	Req *user.ForgotPasswordReq
}

func (p *ForgotPasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ForgotPasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ForgotPasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ForgotPasswordArgs_Req_DEFAULT *user.ForgotPasswordReq

func (p *ForgotPasswordArgs) GetReq() *user.ForgotPasswordReq {
	if !p.IsSetReq() {
		return ForgotPasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ForgotPasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ForgotPasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ForgotPasswordResult struct {
	Success *user.OperationResult
}

var ForgotPasswordResult_Success_DEFAULT *user.OperationResult

func (p *ForgotPasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ForgotPasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ForgotPasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ForgotPasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ForgotPasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ForgotPasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForgotPasswordResult) GetResult() interface{} {
	return p.Success
}

func resetPasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ResetPasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ResetPassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ResetPasswordArgs:
		success, err := handler.(user.UserService).ResetPassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ResetPasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newResetPasswordArgs() interface{} {
	return &ResetPasswordArgs{}
}

func newResetPasswordResult() interface{} {
	return &ResetPasswordResult{}
}

type ResetPasswordArgs struct {
	Req *user.ResetPasswordReq
}

func (p *ResetPasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ResetPasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ResetPasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ResetPasswordArgs_Req_DEFAULT *user.ResetPasswordReq

func (p *ResetPasswordArgs) GetReq() *user.ResetPasswordReq {
	if !p.IsSetReq() {
		return ResetPasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ResetPasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ResetPasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ResetPasswordResult struct {
	Success *user.OperationResult
}

var ResetPasswordResult_Success_DEFAULT *user.OperationResult

func (p *ResetPasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ResetPasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ResetPasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ResetPasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ResetPasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ResetPasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ResetPasswordResult) GetResult() interface{} {
	return p.Success
}

func startBindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartBindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartBindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartBindEmailArgs:
		success, err := handler.(user.UserService).StartBindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartBindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartBindEmailArgs() interface{} {
	return &StartBindEmailArgs{}
}

func newStartBindEmailResult() interface{} {
	return &StartBindEmailResult{}
}

type StartBindEmailArgs struct {
	Req *user.StartBindEmailReq
}

func (p *StartBindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartBindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.StartBindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartBindEmailArgs_Req_DEFAULT *user.StartBindEmailReq

func (p *StartBindEmailArgs) GetReq() *user.StartBindEmailReq {
	if !p.IsSetReq() {
		return StartBindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartBindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartBindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartBindEmailResult struct {
	Success *user.OperationResult
}

var StartBindEmailResult_Success_DEFAULT *user.OperationResult

func (p *StartBindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartBindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartBindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartBindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartBindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartBindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartBindEmailResult) GetResult() interface{} {
	return p.Success
}

func completeBindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteBindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteBindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteBindEmailArgs:
		success, err := handler.(user.UserService).CompleteBindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteBindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteBindEmailArgs() interface{} {
	return &CompleteBindEmailArgs{}
}

func newCompleteBindEmailResult() interface{} {
	return &CompleteBindEmailResult{}
}

type CompleteBindEmailArgs struct {
	Req *user.CompleteBindEmailReq
}

func (p *CompleteBindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteBindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteBindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteBindEmailArgs_Req_DEFAULT *user.CompleteBindEmailReq

func (p *CompleteBindEmailArgs) GetReq() *user.CompleteBindEmailReq {
	if !p.IsSetReq() {
		return CompleteBindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteBindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteBindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteBindEmailResult struct {
	Success *user.OperationResult
}

var CompleteBindEmailResult_Success_DEFAULT *user.OperationResult

func (p *CompleteBindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteBindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteBindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteBindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteBindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteBindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteBindEmailResult) GetResult() interface{} {
	return p.Success
}

func startChangeEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartChangeEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartChangeEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartChangeEmailArgs:
		success, err := handler.(user.UserService).StartChangeEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartChangeEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartChangeEmailArgs() interface{} {
	return &StartChangeEmailArgs{}
}

func newStartChangeEmailResult() interface{} {
	return &StartChangeEmailResult{}
}

type StartChangeEmailArgs struct {
	Req *user.StartChangeEmailReq
}

func (p *StartChangeEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartChangeEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.StartChangeEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartChangeEmailArgs_Req_DEFAULT *user.StartChangeEmailReq

func (p *StartChangeEmailArgs) GetReq() *user.StartChangeEmailReq {
	if !p.IsSetReq() {
		return StartChangeEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartChangeEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartChangeEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartChangeEmailResult struct {
	Success *user.OperationResult
}

var StartChangeEmailResult_Success_DEFAULT *user.OperationResult

func (p *StartChangeEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartChangeEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartChangeEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartChangeEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartChangeEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartChangeEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartChangeEmailResult) GetResult() interface{} {
	return p.Success
}

func verifyNewEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.VerifyNewEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).VerifyNewEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyNewEmailArgs:
		success, err := handler.(user.UserService).VerifyNewEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyNewEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyNewEmailArgs() interface{} {
	return &VerifyNewEmailArgs{}
}

func newVerifyNewEmailResult() interface{} {
	return &VerifyNewEmailResult{}
}

type VerifyNewEmailArgs struct {
	Req *user.VerifyNewEmailReq
}

func (p *VerifyNewEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyNewEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.VerifyNewEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyNewEmailArgs_Req_DEFAULT *user.VerifyNewEmailReq

func (p *VerifyNewEmailArgs) GetReq() *user.VerifyNewEmailReq {
	if !p.IsSetReq() {
		return VerifyNewEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyNewEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyNewEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyNewEmailResult struct {
	Success *user.OperationResult
}

var VerifyNewEmailResult_Success_DEFAULT *user.OperationResult

func (p *VerifyNewEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyNewEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyNewEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return VerifyNewEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyNewEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *VerifyNewEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyNewEmailResult) GetResult() interface{} {
	return p.Success
}

func completeChangeEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteChangeEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteChangeEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteChangeEmailArgs:
		success, err := handler.(user.UserService).CompleteChangeEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteChangeEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteChangeEmailArgs() interface{} {
	return &CompleteChangeEmailArgs{}
}

func newCompleteChangeEmailResult() interface{} {
	return &CompleteChangeEmailResult{}
}

type CompleteChangeEmailArgs struct {
	Req *user.CompleteChangeEmailReq
}

func (p *CompleteChangeEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteChangeEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteChangeEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteChangeEmailArgs_Req_DEFAULT *user.CompleteChangeEmailReq

func (p *CompleteChangeEmailArgs) GetReq() *user.CompleteChangeEmailReq {
	if !p.IsSetReq() {
		return CompleteChangeEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteChangeEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteChangeEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteChangeEmailResult struct {
	Success *user.OperationResult
}

var CompleteChangeEmailResult_Success_DEFAULT *user.OperationResult

func (p *CompleteChangeEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteChangeEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteChangeEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteChangeEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteChangeEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteChangeEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteChangeEmailResult) GetResult() interface{} {
	return p.Success
}

func startBindPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartBindPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartBindPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartBindPhoneArgs:
		success, err := handler.(user.UserService).StartBindPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartBindPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartBindPhoneArgs() interface{} {
	return &StartBindPhoneArgs{}
}

func newStartBindPhoneResult() interface{} {
	return &StartBindPhoneResult{}
}

type StartBindPhoneArgs struct {
	Req *user.StartBindPhoneReq
}

func (p *StartBindPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartBindPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.StartBindPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartBindPhoneArgs_Req_DEFAULT *user.StartBindPhoneReq

func (p *StartBindPhoneArgs) GetReq() *user.StartBindPhoneReq {
	if !p.IsSetReq() {
		return StartBindPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartBindPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartBindPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartBindPhoneResult struct {
	Success *user.OperationResult
}

var StartBindPhoneResult_Success_DEFAULT *user.OperationResult

func (p *StartBindPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartBindPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartBindPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartBindPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartBindPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartBindPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartBindPhoneResult) GetResult() interface{} {
	return p.Success
}

func completeBindPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteBindPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteBindPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteBindPhoneArgs:
		success, err := handler.(user.UserService).CompleteBindPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteBindPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteBindPhoneArgs() interface{} {
	return &CompleteBindPhoneArgs{}
}

func newCompleteBindPhoneResult() interface{} {
	return &CompleteBindPhoneResult{}
}

type CompleteBindPhoneArgs struct {
	Req *user.CompleteBindPhoneReq
}

func (p *CompleteBindPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteBindPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteBindPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteBindPhoneArgs_Req_DEFAULT *user.CompleteBindPhoneReq

func (p *CompleteBindPhoneArgs) GetReq() *user.CompleteBindPhoneReq {
	if !p.IsSetReq() {
		return CompleteBindPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteBindPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteBindPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteBindPhoneResult struct {
	Success *user.OperationResult
}

var CompleteBindPhoneResult_Success_DEFAULT *user.OperationResult

func (p *CompleteBindPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteBindPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteBindPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteBindPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteBindPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteBindPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteBindPhoneResult) GetResult() interface{} {
	return p.Success
}

func startChangePhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartChangePhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartChangePhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartChangePhoneArgs:
		success, err := handler.(user.UserService).StartChangePhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartChangePhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartChangePhoneArgs() interface{} {
	return &StartChangePhoneArgs{}
}

func newStartChangePhoneResult() interface{} {
	return &StartChangePhoneResult{}
}

type StartChangePhoneArgs struct {
	Req *user.StartChangePhoneReq
}

func (p *StartChangePhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartChangePhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.StartChangePhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartChangePhoneArgs_Req_DEFAULT *user.StartChangePhoneReq

func (p *StartChangePhoneArgs) GetReq() *user.StartChangePhoneReq {
	if !p.IsSetReq() {
		return StartChangePhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartChangePhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartChangePhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartChangePhoneResult struct {
	Success *user.OperationResult
}

var StartChangePhoneResult_Success_DEFAULT *user.OperationResult

func (p *StartChangePhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartChangePhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartChangePhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartChangePhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartChangePhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartChangePhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartChangePhoneResult) GetResult() interface{} {
	return p.Success
}

func verifyNewPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.VerifyNewPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).VerifyNewPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyNewPhoneArgs:
		success, err := handler.(user.UserService).VerifyNewPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyNewPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyNewPhoneArgs() interface{} {
	return &VerifyNewPhoneArgs{}
}

func newVerifyNewPhoneResult() interface{} {
	return &VerifyNewPhoneResult{}
}

type VerifyNewPhoneArgs struct {
	Req *user.VerifyNewPhoneReq
}

func (p *VerifyNewPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyNewPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.VerifyNewPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyNewPhoneArgs_Req_DEFAULT *user.VerifyNewPhoneReq

func (p *VerifyNewPhoneArgs) GetReq() *user.VerifyNewPhoneReq {
	if !p.IsSetReq() {
		return VerifyNewPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyNewPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyNewPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyNewPhoneResult struct {
	Success *user.OperationResult
}

var VerifyNewPhoneResult_Success_DEFAULT *user.OperationResult

func (p *VerifyNewPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyNewPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyNewPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return VerifyNewPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyNewPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *VerifyNewPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyNewPhoneResult) GetResult() interface{} {
	return p.Success
}

func completeChangePhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteChangePhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteChangePhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteChangePhoneArgs:
		success, err := handler.(user.UserService).CompleteChangePhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteChangePhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteChangePhoneArgs() interface{} {
	return &CompleteChangePhoneArgs{}
}

func newCompleteChangePhoneResult() interface{} {
	return &CompleteChangePhoneResult{}
}

type CompleteChangePhoneArgs struct {
	Req *user.CompleteChangePhoneReq
}

func (p *CompleteChangePhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteChangePhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteChangePhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteChangePhoneArgs_Req_DEFAULT *user.CompleteChangePhoneReq

func (p *CompleteChangePhoneArgs) GetReq() *user.CompleteChangePhoneReq {
	if !p.IsSetReq() {
		return CompleteChangePhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteChangePhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteChangePhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteChangePhoneResult struct {
	Success *user.OperationResult
}

var CompleteChangePhoneResult_Success_DEFAULT *user.OperationResult

func (p *CompleteChangePhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteChangePhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteChangePhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteChangePhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteChangePhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteChangePhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteChangePhoneResult) GetResult() interface{} {
	return p.Success
}

func getUserInfoByIdHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetUserInfoByIdReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).GetUserInfoById(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserInfoByIdArgs:
		success, err := handler.(user.UserService).GetUserInfoById(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserInfoByIdResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserInfoByIdArgs() interface{} {
	return &GetUserInfoByIdArgs{}
}

func newGetUserInfoByIdResult() interface{} {
	return &GetUserInfoByIdResult{}
}

type GetUserInfoByIdArgs struct {
	Req *user.GetUserInfoByIdReq
}

func (p *GetUserInfoByIdArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserInfoByIdArgs) Unmarshal(in []byte) error {
	msg := new(user.GetUserInfoByIdReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserInfoByIdArgs_Req_DEFAULT *user.GetUserInfoByIdReq

func (p *GetUserInfoByIdArgs) GetReq() *user.GetUserInfoByIdReq {
	if !p.IsSetReq() {
		return GetUserInfoByIdArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserInfoByIdArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserInfoByIdArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserInfoByIdResult struct {
	Success *user.UserInfoResp
}

var GetUserInfoByIdResult_Success_DEFAULT *user.UserInfoResp

func (p *GetUserInfoByIdResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserInfoByIdResult) Unmarshal(in []byte) error {
	msg := new(user.UserInfoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserInfoByIdResult) GetSuccess() *user.UserInfoResp {
	if !p.IsSetSuccess() {
		return GetUserInfoByIdResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserInfoByIdResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.UserInfoResp)
}

func (p *GetUserInfoByIdResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserInfoByIdResult) GetResult() interface{} {
	return p.Success
}

func getUserInfoByOthersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetUserInfoByOthersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).GetUserInfoByOthers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserInfoByOthersArgs:
		success, err := handler.(user.UserService).GetUserInfoByOthers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserInfoByOthersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserInfoByOthersArgs() interface{} {
	return &GetUserInfoByOthersArgs{}
}

func newGetUserInfoByOthersResult() interface{} {
	return &GetUserInfoByOthersResult{}
}

type GetUserInfoByOthersArgs struct {
	Req *user.GetUserInfoByOthersReq
}

func (p *GetUserInfoByOthersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserInfoByOthersArgs) Unmarshal(in []byte) error {
	msg := new(user.GetUserInfoByOthersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserInfoByOthersArgs_Req_DEFAULT *user.GetUserInfoByOthersReq

func (p *GetUserInfoByOthersArgs) GetReq() *user.GetUserInfoByOthersReq {
	if !p.IsSetReq() {
		return GetUserInfoByOthersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserInfoByOthersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserInfoByOthersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserInfoByOthersResult struct {
	Success *user.UserInfoResp
}

var GetUserInfoByOthersResult_Success_DEFAULT *user.UserInfoResp

func (p *GetUserInfoByOthersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserInfoByOthersResult) Unmarshal(in []byte) error {
	msg := new(user.UserInfoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserInfoByOthersResult) GetSuccess() *user.UserInfoResp {
	if !p.IsSetSuccess() {
		return GetUserInfoByOthersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserInfoByOthersResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.UserInfoResp)
}

func (p *GetUserInfoByOthersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserInfoByOthersResult) GetResult() interface{} {
	return p.Success
}

func updateUserInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.UpdateUserInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).UpdateUserInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserInfoArgs:
		success, err := handler.(user.UserService).UpdateUserInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserInfoArgs() interface{} {
	return &UpdateUserInfoArgs{}
}

func newUpdateUserInfoResult() interface{} {
	return &UpdateUserInfoResult{}
}

type UpdateUserInfoArgs struct {
	Req *user.UpdateUserInfoReq
}

func (p *UpdateUserInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserInfoArgs_Req_DEFAULT *user.UpdateUserInfoReq

func (p *UpdateUserInfoArgs) GetReq() *user.UpdateUserInfoReq {
	if !p.IsSetReq() {
		return UpdateUserInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserInfoResult struct {
	Success *user.OperationResult
}

var UpdateUserInfoResult_Success_DEFAULT *user.OperationResult

func (p *UpdateUserInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserInfoResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserInfoResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return UpdateUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *UpdateUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserInfoResult) GetResult() interface{} {
	return p.Success
}

func listUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ListUsersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ListUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListUsersArgs:
		success, err := handler.(user.UserService).ListUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListUsersArgs() interface{} {
	return &ListUsersArgs{}
}

func newListUsersResult() interface{} {
	return &ListUsersResult{}
}

type ListUsersArgs struct {
	Req *user.ListUsersReq
}

func (p *ListUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListUsersArgs) Unmarshal(in []byte) error {
	msg := new(user.ListUsersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListUsersArgs_Req_DEFAULT *user.ListUsersReq

func (p *ListUsersArgs) GetReq() *user.ListUsersReq {
	if !p.IsSetReq() {
		return ListUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListUsersResult struct {
	Success *user.ListUsersResp
}

var ListUsersResult_Success_DEFAULT *user.ListUsersResp

func (p *ListUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListUsersResult) Unmarshal(in []byte) error {
	msg := new(user.ListUsersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListUsersResult) GetSuccess() *user.ListUsersResp {
	if !p.IsSetSuccess() {
		return ListUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ListUsersResp)
}

func (p *ListUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListUsersResult) GetResult() interface{} {
	return p.Success
}

func searchUserByNicknameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SearchUserByNicknameReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SearchUserByNickname(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchUserByNicknameArgs:
		success, err := handler.(user.UserService).SearchUserByNickname(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchUserByNicknameResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchUserByNicknameArgs() interface{} {
	return &SearchUserByNicknameArgs{}
}

func newSearchUserByNicknameResult() interface{} {
	return &SearchUserByNicknameResult{}
}

type SearchUserByNicknameArgs struct {
	Req *user.SearchUserByNicknameReq
}

func (p *SearchUserByNicknameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchUserByNicknameArgs) Unmarshal(in []byte) error {
	msg := new(user.SearchUserByNicknameReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchUserByNicknameArgs_Req_DEFAULT *user.SearchUserByNicknameReq

func (p *SearchUserByNicknameArgs) GetReq() *user.SearchUserByNicknameReq {
	if !p.IsSetReq() {
		return SearchUserByNicknameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchUserByNicknameArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchUserByNicknameArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchUserByNicknameResult struct {
	Success *user.SearchUserByNicknameResp
}

var SearchUserByNicknameResult_Success_DEFAULT *user.SearchUserByNicknameResp

func (p *SearchUserByNicknameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchUserByNicknameResult) Unmarshal(in []byte) error {
	msg := new(user.SearchUserByNicknameResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchUserByNicknameResult) GetSuccess() *user.SearchUserByNicknameResp {
	if !p.IsSetSuccess() {
		return SearchUserByNicknameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchUserByNicknameResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SearchUserByNicknameResp)
}

func (p *SearchUserByNicknameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchUserByNicknameResult) GetResult() interface{} {
	return p.Success
}

func startDeactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartDeactivateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartDeactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartDeactivateUserArgs:
		success, err := handler.(user.UserService).StartDeactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartDeactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartDeactivateUserArgs() interface{} {
	return &StartDeactivateUserArgs{}
}

func newStartDeactivateUserResult() interface{} {
	return &StartDeactivateUserResult{}
}

type StartDeactivateUserArgs struct {
	Req *user.StartDeactivateReq
}

func (p *StartDeactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartDeactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.StartDeactivateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartDeactivateUserArgs_Req_DEFAULT *user.StartDeactivateReq

func (p *StartDeactivateUserArgs) GetReq() *user.StartDeactivateReq {
	if !p.IsSetReq() {
		return StartDeactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartDeactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartDeactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartDeactivateUserResult struct {
	Success *user.OperationResult
}

var StartDeactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *StartDeactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartDeactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartDeactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartDeactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartDeactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartDeactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartDeactivateUserResult) GetResult() interface{} {
	return p.Success
}

func deactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.DeactivateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).DeactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeactivateUserArgs:
		success, err := handler.(user.UserService).DeactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeactivateUserArgs() interface{} {
	return &DeactivateUserArgs{}
}

func newDeactivateUserResult() interface{} {
	return &DeactivateUserResult{}
}

type DeactivateUserArgs struct {
	Req *user.DeactivateUserReq
}

func (p *DeactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.DeactivateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeactivateUserArgs_Req_DEFAULT *user.DeactivateUserReq

func (p *DeactivateUserArgs) GetReq() *user.DeactivateUserReq {
	if !p.IsSetReq() {
		return DeactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeactivateUserResult struct {
	Success *user.OperationResult
}

var DeactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *DeactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return DeactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *DeactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeactivateUserResult) GetResult() interface{} {
	return p.Success
}

func reactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ReactivateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ReactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ReactivateUserArgs:
		success, err := handler.(user.UserService).ReactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ReactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newReactivateUserArgs() interface{} {
	return &ReactivateUserArgs{}
}

func newReactivateUserResult() interface{} {
	return &ReactivateUserResult{}
}

type ReactivateUserArgs struct {
	Req *user.ReactivateUserReq
}

func (p *ReactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ReactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.ReactivateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ReactivateUserArgs_Req_DEFAULT *user.ReactivateUserReq

func (p *ReactivateUserArgs) GetReq() *user.ReactivateUserReq {
	if !p.IsSetReq() {
		return ReactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ReactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ReactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ReactivateUserResult struct {
	Success *user.OperationResult
}

var ReactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *ReactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ReactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ReactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ReactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ReactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ReactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReactivateUserResult) GetResult() interface{} {
	return p.Success
}

func startDeleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartDeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartDeleteUserArgs:
		success, err := handler.(user.UserService).StartDeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartDeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartDeleteUserArgs() interface{} {
	return &StartDeleteUserArgs{}
}

func newStartDeleteUserResult() interface{} {
	return &StartDeleteUserResult{}
}

type StartDeleteUserArgs struct {
	Req *user.StartDeleteReq
}

func (p *StartDeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartDeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(user.StartDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartDeleteUserArgs_Req_DEFAULT *user.StartDeleteReq

func (p *StartDeleteUserArgs) GetReq() *user.StartDeleteReq {
	if !p.IsSetReq() {
		return StartDeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartDeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartDeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartDeleteUserResult struct {
	Success *user.OperationResult
}

var StartDeleteUserResult_Success_DEFAULT *user.OperationResult

func (p *StartDeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartDeleteUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartDeleteUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartDeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartDeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartDeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartDeleteUserResult) GetResult() interface{} {
	return p.Success
}

func deleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.DeleteUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).DeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUserArgs:
		success, err := handler.(user.UserService).DeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUserArgs() interface{} {
	return &DeleteUserArgs{}
}

func newDeleteUserResult() interface{} {
	return &DeleteUserResult{}
}

type DeleteUserArgs struct {
	Req *user.DeleteUserReq
}

func (p *DeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(user.DeleteUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUserArgs_Req_DEFAULT *user.DeleteUserReq

func (p *DeleteUserArgs) GetReq() *user.DeleteUserReq {
	if !p.IsSetReq() {
		return DeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUserResult struct {
	Success *user.OperationResult
}

var DeleteUserResult_Success_DEFAULT *user.OperationResult

func (p *DeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return DeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *DeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUserResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Register(ctx context.Context, Req *user.RegisterReq) (r *user.OperationResult, err error) {
	var _args RegisterArgs
	_args.Req = Req
	var _result RegisterResult
	if err = p.c.Call(ctx, "Register", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) EmailLogin(ctx context.Context, Req *user.EmailLoginReq) (r *user.LoginResp, err error) {
	var _args EmailLoginArgs
	_args.Req = Req
	var _result EmailLoginResult
	if err = p.c.Call(ctx, "EmailLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PhoneLogin(ctx context.Context, Req *user.PhoneLoginReq) (r *user.LoginResp, err error) {
	var _args PhoneLoginArgs
	_args.Req = Req
	var _result PhoneLoginResult
	if err = p.c.Call(ctx, "PhoneLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AccountLogin(ctx context.Context, Req *user.AccountLoginReq) (r *user.LoginResp, err error) {
	var _args AccountLoginArgs
	_args.Req = Req
	var _result AccountLoginResult
	if err = p.c.Call(ctx, "AccountLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SmsLogin(ctx context.Context, Req *user.SmsLoginReq) (r *user.SmsLoginResp, err error) {
	var _args SmsLoginArgs
	_args.Req = Req
	var _result SmsLoginResult
	if err = p.c.Call(ctx, "SmsLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GenerateQrCode(ctx context.Context, Req *user.GenerateQrCodeReq) (r *user.GenerateQrCodeResp, err error) {
	var _args GenerateQrCodeArgs
	_args.Req = Req
	var _result GenerateQrCodeResult
	if err = p.c.Call(ctx, "GenerateQrCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QrCodePreLoginStatus(ctx context.Context, Req *user.QrCodePreLoginStatusReq) (r *user.QrCodePreLoginStatusResp, err error) {
	var _args QrCodePreLoginStatusArgs
	_args.Req = Req
	var _result QrCodePreLoginStatusResult
	if err = p.c.Call(ctx, "QrCodePreLoginStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QrCodeLoginStatus(ctx context.Context, Req *user.QrCodeLoginStatusReq) (r *user.QrCodeLoginStatusResp, err error) {
	var _args QrCodeLoginStatusArgs
	_args.Req = Req
	var _result QrCodeLoginStatusResult
	if err = p.c.Call(ctx, "QrCodeLoginStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QrPreLogin(ctx context.Context, Req *user.QrPreLoginReq) (r *user.QrPreLoginResp, err error) {
	var _args QrPreLoginArgs
	_args.Req = Req
	var _result QrPreLoginResult
	if err = p.c.Call(ctx, "QrPreLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ConfirmQrLogin(ctx context.Context, Req *user.ConfirmQrLoginReq) (r *user.Empty, err error) {
	var _args ConfirmQrLoginArgs
	_args.Req = Req
	var _result ConfirmQrLoginResult
	if err = p.c.Call(ctx, "ConfirmQrLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CancelQrLogin(ctx context.Context, Req *user.CancelQrLoginReq) (r *user.Empty, err error) {
	var _args CancelQrLoginArgs
	_args.Req = Req
	var _result CancelQrLoginResult
	if err = p.c.Call(ctx, "CancelQrLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) OAuthLogin(ctx context.Context, Req *user.OAuthLoginReq) (r *user.LoginResp, err error) {
	var _args OAuthLoginArgs
	_args.Req = Req
	var _result OAuthLoginResult
	if err = p.c.Call(ctx, "OAuthLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Logout(ctx context.Context, Req *user.LogoutReq) (r *user.OperationResult, err error) {
	var _args LogoutArgs
	_args.Req = Req
	var _result LogoutResult
	if err = p.c.Call(ctx, "Logout", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ChangePassword(ctx context.Context, Req *user.ChangePasswordReq) (r *user.OperationResult, err error) {
	var _args ChangePasswordArgs
	_args.Req = Req
	var _result ChangePasswordResult
	if err = p.c.Call(ctx, "ChangePassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ForgotPassword(ctx context.Context, Req *user.ForgotPasswordReq) (r *user.OperationResult, err error) {
	var _args ForgotPasswordArgs
	_args.Req = Req
	var _result ForgotPasswordResult
	if err = p.c.Call(ctx, "ForgotPassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ResetPassword(ctx context.Context, Req *user.ResetPasswordReq) (r *user.OperationResult, err error) {
	var _args ResetPasswordArgs
	_args.Req = Req
	var _result ResetPasswordResult
	if err = p.c.Call(ctx, "ResetPassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartBindEmail(ctx context.Context, Req *user.StartBindEmailReq) (r *user.OperationResult, err error) {
	var _args StartBindEmailArgs
	_args.Req = Req
	var _result StartBindEmailResult
	if err = p.c.Call(ctx, "StartBindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteBindEmail(ctx context.Context, Req *user.CompleteBindEmailReq) (r *user.OperationResult, err error) {
	var _args CompleteBindEmailArgs
	_args.Req = Req
	var _result CompleteBindEmailResult
	if err = p.c.Call(ctx, "CompleteBindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartChangeEmail(ctx context.Context, Req *user.StartChangeEmailReq) (r *user.OperationResult, err error) {
	var _args StartChangeEmailArgs
	_args.Req = Req
	var _result StartChangeEmailResult
	if err = p.c.Call(ctx, "StartChangeEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyNewEmail(ctx context.Context, Req *user.VerifyNewEmailReq) (r *user.OperationResult, err error) {
	var _args VerifyNewEmailArgs
	_args.Req = Req
	var _result VerifyNewEmailResult
	if err = p.c.Call(ctx, "VerifyNewEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteChangeEmail(ctx context.Context, Req *user.CompleteChangeEmailReq) (r *user.OperationResult, err error) {
	var _args CompleteChangeEmailArgs
	_args.Req = Req
	var _result CompleteChangeEmailResult
	if err = p.c.Call(ctx, "CompleteChangeEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartBindPhone(ctx context.Context, Req *user.StartBindPhoneReq) (r *user.OperationResult, err error) {
	var _args StartBindPhoneArgs
	_args.Req = Req
	var _result StartBindPhoneResult
	if err = p.c.Call(ctx, "StartBindPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteBindPhone(ctx context.Context, Req *user.CompleteBindPhoneReq) (r *user.OperationResult, err error) {
	var _args CompleteBindPhoneArgs
	_args.Req = Req
	var _result CompleteBindPhoneResult
	if err = p.c.Call(ctx, "CompleteBindPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartChangePhone(ctx context.Context, Req *user.StartChangePhoneReq) (r *user.OperationResult, err error) {
	var _args StartChangePhoneArgs
	_args.Req = Req
	var _result StartChangePhoneResult
	if err = p.c.Call(ctx, "StartChangePhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyNewPhone(ctx context.Context, Req *user.VerifyNewPhoneReq) (r *user.OperationResult, err error) {
	var _args VerifyNewPhoneArgs
	_args.Req = Req
	var _result VerifyNewPhoneResult
	if err = p.c.Call(ctx, "VerifyNewPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteChangePhone(ctx context.Context, Req *user.CompleteChangePhoneReq) (r *user.OperationResult, err error) {
	var _args CompleteChangePhoneArgs
	_args.Req = Req
	var _result CompleteChangePhoneResult
	if err = p.c.Call(ctx, "CompleteChangePhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserInfoById(ctx context.Context, Req *user.GetUserInfoByIdReq) (r *user.UserInfoResp, err error) {
	var _args GetUserInfoByIdArgs
	_args.Req = Req
	var _result GetUserInfoByIdResult
	if err = p.c.Call(ctx, "GetUserInfoById", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserInfoByOthers(ctx context.Context, Req *user.GetUserInfoByOthersReq) (r *user.UserInfoResp, err error) {
	var _args GetUserInfoByOthersArgs
	_args.Req = Req
	var _result GetUserInfoByOthersResult
	if err = p.c.Call(ctx, "GetUserInfoByOthers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUserInfo(ctx context.Context, Req *user.UpdateUserInfoReq) (r *user.OperationResult, err error) {
	var _args UpdateUserInfoArgs
	_args.Req = Req
	var _result UpdateUserInfoResult
	if err = p.c.Call(ctx, "UpdateUserInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListUsers(ctx context.Context, Req *user.ListUsersReq) (r *user.ListUsersResp, err error) {
	var _args ListUsersArgs
	_args.Req = Req
	var _result ListUsersResult
	if err = p.c.Call(ctx, "ListUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchUserByNickname(ctx context.Context, Req *user.SearchUserByNicknameReq) (r *user.SearchUserByNicknameResp, err error) {
	var _args SearchUserByNicknameArgs
	_args.Req = Req
	var _result SearchUserByNicknameResult
	if err = p.c.Call(ctx, "SearchUserByNickname", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartDeactivateUser(ctx context.Context, Req *user.StartDeactivateReq) (r *user.OperationResult, err error) {
	var _args StartDeactivateUserArgs
	_args.Req = Req
	var _result StartDeactivateUserResult
	if err = p.c.Call(ctx, "StartDeactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeactivateUser(ctx context.Context, Req *user.DeactivateUserReq) (r *user.OperationResult, err error) {
	var _args DeactivateUserArgs
	_args.Req = Req
	var _result DeactivateUserResult
	if err = p.c.Call(ctx, "DeactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ReactivateUser(ctx context.Context, Req *user.ReactivateUserReq) (r *user.OperationResult, err error) {
	var _args ReactivateUserArgs
	_args.Req = Req
	var _result ReactivateUserResult
	if err = p.c.Call(ctx, "ReactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartDeleteUser(ctx context.Context, Req *user.StartDeleteReq) (r *user.OperationResult, err error) {
	var _args StartDeleteUserArgs
	_args.Req = Req
	var _result StartDeleteUserResult
	if err = p.c.Call(ctx, "StartDeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUser(ctx context.Context, Req *user.DeleteUserReq) (r *user.OperationResult, err error) {
	var _args DeleteUserArgs
	_args.Req = Req
	var _result DeleteUserResult
	if err = p.c.Call(ctx, "DeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
