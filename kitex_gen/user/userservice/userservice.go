// Code generated by Kitex v0.14.1. DO NOT EDIT.

package userservice

import (
	"context"
	"errors"
	user "github.com/123508/xservergo/kitex_gen/user"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	streaming "github.com/cloudwego/kitex/pkg/streaming"
	proto "github.com/cloudwego/prutal"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"Register": kitex.NewMethodInfo(
		registerHandler,
		newRegisterArgs,
		newRegisterResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"EmailLogin": kitex.NewMethodInfo(
		emailLoginHandler,
		newEmailLoginArgs,
		newEmailLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"PhoneLogin": kitex.NewMethodInfo(
		phoneLoginHandler,
		newPhoneLoginArgs,
		newPhoneLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"AccountLogin": kitex.NewMethodInfo(
		accountLoginHandler,
		newAccountLoginArgs,
		newAccountLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SmsLogin": kitex.NewMethodInfo(
		smsLoginHandler,
		newSmsLoginArgs,
		newSmsLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"QrCodeLogin": kitex.NewMethodInfo(
		qrCodeLoginHandler,
		newQrCodeLoginArgs,
		newQrCodeLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ConfirmQrLogin": kitex.NewMethodInfo(
		confirmQrLoginHandler,
		newConfirmQrLoginArgs,
		newConfirmQrLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"OAuthLogin": kitex.NewMethodInfo(
		oAuthLoginHandler,
		newOAuthLoginArgs,
		newOAuthLoginResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"Logout": kitex.NewMethodInfo(
		logoutHandler,
		newLogoutArgs,
		newLogoutResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SessionCheck": kitex.NewMethodInfo(
		sessionCheckHandler,
		newSessionCheckArgs,
		newSessionCheckResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ChangePassword": kitex.NewMethodInfo(
		changePasswordHandler,
		newChangePasswordArgs,
		newChangePasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ForgotPassword": kitex.NewMethodInfo(
		forgotPasswordHandler,
		newForgotPasswordArgs,
		newForgotPasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ResetPassword": kitex.NewMethodInfo(
		resetPasswordHandler,
		newResetPasswordArgs,
		newResetPasswordResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartBindEmail": kitex.NewMethodInfo(
		startBindEmailHandler,
		newStartBindEmailArgs,
		newStartBindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteBindEmail": kitex.NewMethodInfo(
		completeBindEmailHandler,
		newCompleteBindEmailArgs,
		newCompleteBindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartUnbindEmail": kitex.NewMethodInfo(
		startUnbindEmailHandler,
		newStartUnbindEmailArgs,
		newStartUnbindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteUnbindEmail": kitex.NewMethodInfo(
		completeUnbindEmailHandler,
		newCompleteUnbindEmailArgs,
		newCompleteUnbindEmailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartBindPhone": kitex.NewMethodInfo(
		startBindPhoneHandler,
		newStartBindPhoneArgs,
		newStartBindPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteBindPhone": kitex.NewMethodInfo(
		completeBindPhoneHandler,
		newCompleteBindPhoneArgs,
		newCompleteBindPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartChangePhone": kitex.NewMethodInfo(
		startChangePhoneHandler,
		newStartChangePhoneArgs,
		newStartChangePhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifyNewPhone": kitex.NewMethodInfo(
		verifyNewPhoneHandler,
		newVerifyNewPhoneArgs,
		newVerifyNewPhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"CompleteChangePhone": kitex.NewMethodInfo(
		completeChangePhoneHandler,
		newCompleteChangePhoneArgs,
		newCompleteChangePhoneResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"GetUserInfo": kitex.NewMethodInfo(
		getUserInfoHandler,
		newGetUserInfoArgs,
		newGetUserInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"UpdateUserInfo": kitex.NewMethodInfo(
		updateUserInfoHandler,
		newUpdateUserInfoArgs,
		newUpdateUserInfoResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ListUsers": kitex.NewMethodInfo(
		listUsersHandler,
		newListUsersArgs,
		newListUsersResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SearchUserByNickname": kitex.NewMethodInfo(
		searchUserByNicknameHandler,
		newSearchUserByNicknameArgs,
		newSearchUserByNicknameResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartDeactivateUser": kitex.NewMethodInfo(
		startDeactivateUserHandler,
		newStartDeactivateUserArgs,
		newStartDeactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeactivateUser": kitex.NewMethodInfo(
		deactivateUserHandler,
		newDeactivateUserArgs,
		newDeactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"ReactivateUser": kitex.NewMethodInfo(
		reactivateUserHandler,
		newReactivateUserArgs,
		newReactivateUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"StartDeleteUser": kitex.NewMethodInfo(
		startDeleteUserHandler,
		newStartDeleteUserArgs,
		newStartDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"DeleteUser": kitex.NewMethodInfo(
		deleteUserHandler,
		newDeleteUserArgs,
		newDeleteUserResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"VerifySecurityCode": kitex.NewMethodInfo(
		verifySecurityCodeHandler,
		newVerifySecurityCodeArgs,
		newVerifySecurityCodeResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
	"SendVerification": kitex.NewMethodInfo(
		sendVerificationHandler,
		newSendVerificationArgs,
		newSendVerificationResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingUnary),
	),
}

var (
	userServiceServiceInfo                = NewServiceInfo()
	userServiceServiceInfoForClient       = NewServiceInfoForClient()
	userServiceServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return userServiceServiceInfo
}

// for stream cli
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForStreamClient
}

// for cli
func serviceInfoForClient() *kitex.ServiceInfo {
	return userServiceServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "UserService"
	handlerType := (*user.UserService)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "user",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.14.1",
		Extra:           extra,
	}
	return svcInfo
}

func registerHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.RegisterReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).Register(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *RegisterArgs:
		success, err := handler.(user.UserService).Register(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegisterResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newRegisterArgs() interface{} {
	return &RegisterArgs{}
}

func newRegisterResult() interface{} {
	return &RegisterResult{}
}

type RegisterArgs struct {
	Req *user.RegisterReq
}

func (p *RegisterArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *RegisterArgs) Unmarshal(in []byte) error {
	msg := new(user.RegisterReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegisterArgs_Req_DEFAULT *user.RegisterReq

func (p *RegisterArgs) GetReq() *user.RegisterReq {
	if !p.IsSetReq() {
		return RegisterArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegisterArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *RegisterArgs) GetFirstArgument() interface{} {
	return p.Req
}

type RegisterResult struct {
	Success *user.OperationResult
}

var RegisterResult_Success_DEFAULT *user.OperationResult

func (p *RegisterResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *RegisterResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegisterResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return RegisterResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegisterResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *RegisterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *RegisterResult) GetResult() interface{} {
	return p.Success
}

func emailLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.EmailLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).EmailLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *EmailLoginArgs:
		success, err := handler.(user.UserService).EmailLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*EmailLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newEmailLoginArgs() interface{} {
	return &EmailLoginArgs{}
}

func newEmailLoginResult() interface{} {
	return &EmailLoginResult{}
}

type EmailLoginArgs struct {
	Req *user.EmailLoginReq
}

func (p *EmailLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *EmailLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.EmailLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var EmailLoginArgs_Req_DEFAULT *user.EmailLoginReq

func (p *EmailLoginArgs) GetReq() *user.EmailLoginReq {
	if !p.IsSetReq() {
		return EmailLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *EmailLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *EmailLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type EmailLoginResult struct {
	Success *user.LoginResp
}

var EmailLoginResult_Success_DEFAULT *user.LoginResp

func (p *EmailLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *EmailLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *EmailLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return EmailLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *EmailLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *EmailLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EmailLoginResult) GetResult() interface{} {
	return p.Success
}

func phoneLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.PhoneLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).PhoneLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *PhoneLoginArgs:
		success, err := handler.(user.UserService).PhoneLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PhoneLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newPhoneLoginArgs() interface{} {
	return &PhoneLoginArgs{}
}

func newPhoneLoginResult() interface{} {
	return &PhoneLoginResult{}
}

type PhoneLoginArgs struct {
	Req *user.PhoneLoginReq
}

func (p *PhoneLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *PhoneLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.PhoneLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PhoneLoginArgs_Req_DEFAULT *user.PhoneLoginReq

func (p *PhoneLoginArgs) GetReq() *user.PhoneLoginReq {
	if !p.IsSetReq() {
		return PhoneLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PhoneLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *PhoneLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type PhoneLoginResult struct {
	Success *user.LoginResp
}

var PhoneLoginResult_Success_DEFAULT *user.LoginResp

func (p *PhoneLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *PhoneLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PhoneLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return PhoneLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PhoneLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *PhoneLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PhoneLoginResult) GetResult() interface{} {
	return p.Success
}

func accountLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.AccountLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).AccountLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *AccountLoginArgs:
		success, err := handler.(user.UserService).AccountLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AccountLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newAccountLoginArgs() interface{} {
	return &AccountLoginArgs{}
}

func newAccountLoginResult() interface{} {
	return &AccountLoginResult{}
}

type AccountLoginArgs struct {
	Req *user.AccountLoginReq
}

func (p *AccountLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *AccountLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.AccountLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AccountLoginArgs_Req_DEFAULT *user.AccountLoginReq

func (p *AccountLoginArgs) GetReq() *user.AccountLoginReq {
	if !p.IsSetReq() {
		return AccountLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AccountLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *AccountLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type AccountLoginResult struct {
	Success *user.LoginResp
}

var AccountLoginResult_Success_DEFAULT *user.LoginResp

func (p *AccountLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *AccountLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AccountLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return AccountLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AccountLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *AccountLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AccountLoginResult) GetResult() interface{} {
	return p.Success
}

func smsLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SmsLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SmsLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SmsLoginArgs:
		success, err := handler.(user.UserService).SmsLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SmsLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSmsLoginArgs() interface{} {
	return &SmsLoginArgs{}
}

func newSmsLoginResult() interface{} {
	return &SmsLoginResult{}
}

type SmsLoginArgs struct {
	Req *user.SmsLoginReq
}

func (p *SmsLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SmsLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.SmsLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SmsLoginArgs_Req_DEFAULT *user.SmsLoginReq

func (p *SmsLoginArgs) GetReq() *user.SmsLoginReq {
	if !p.IsSetReq() {
		return SmsLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SmsLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SmsLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SmsLoginResult struct {
	Success *user.SmsLoginResp
}

var SmsLoginResult_Success_DEFAULT *user.SmsLoginResp

func (p *SmsLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SmsLoginResult) Unmarshal(in []byte) error {
	msg := new(user.SmsLoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SmsLoginResult) GetSuccess() *user.SmsLoginResp {
	if !p.IsSetSuccess() {
		return SmsLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SmsLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SmsLoginResp)
}

func (p *SmsLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SmsLoginResult) GetResult() interface{} {
	return p.Success
}

func qrCodeLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.QrCodeLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).QrCodeLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *QrCodeLoginArgs:
		success, err := handler.(user.UserService).QrCodeLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*QrCodeLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newQrCodeLoginArgs() interface{} {
	return &QrCodeLoginArgs{}
}

func newQrCodeLoginResult() interface{} {
	return &QrCodeLoginResult{}
}

type QrCodeLoginArgs struct {
	Req *user.QrCodeLoginReq
}

func (p *QrCodeLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *QrCodeLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.QrCodeLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var QrCodeLoginArgs_Req_DEFAULT *user.QrCodeLoginReq

func (p *QrCodeLoginArgs) GetReq() *user.QrCodeLoginReq {
	if !p.IsSetReq() {
		return QrCodeLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *QrCodeLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *QrCodeLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type QrCodeLoginResult struct {
	Success *user.QrCodeLoginResp
}

var QrCodeLoginResult_Success_DEFAULT *user.QrCodeLoginResp

func (p *QrCodeLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *QrCodeLoginResult) Unmarshal(in []byte) error {
	msg := new(user.QrCodeLoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *QrCodeLoginResult) GetSuccess() *user.QrCodeLoginResp {
	if !p.IsSetSuccess() {
		return QrCodeLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *QrCodeLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.QrCodeLoginResp)
}

func (p *QrCodeLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QrCodeLoginResult) GetResult() interface{} {
	return p.Success
}

func confirmQrLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ConfirmQrLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ConfirmQrLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ConfirmQrLoginArgs:
		success, err := handler.(user.UserService).ConfirmQrLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ConfirmQrLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newConfirmQrLoginArgs() interface{} {
	return &ConfirmQrLoginArgs{}
}

func newConfirmQrLoginResult() interface{} {
	return &ConfirmQrLoginResult{}
}

type ConfirmQrLoginArgs struct {
	Req *user.ConfirmQrLoginReq
}

func (p *ConfirmQrLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ConfirmQrLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.ConfirmQrLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ConfirmQrLoginArgs_Req_DEFAULT *user.ConfirmQrLoginReq

func (p *ConfirmQrLoginArgs) GetReq() *user.ConfirmQrLoginReq {
	if !p.IsSetReq() {
		return ConfirmQrLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ConfirmQrLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ConfirmQrLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ConfirmQrLoginResult struct {
	Success *user.LoginResp
}

var ConfirmQrLoginResult_Success_DEFAULT *user.LoginResp

func (p *ConfirmQrLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ConfirmQrLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ConfirmQrLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return ConfirmQrLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ConfirmQrLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *ConfirmQrLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ConfirmQrLoginResult) GetResult() interface{} {
	return p.Success
}

func oAuthLoginHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.OAuthLoginReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).OAuthLogin(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *OAuthLoginArgs:
		success, err := handler.(user.UserService).OAuthLogin(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*OAuthLoginResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newOAuthLoginArgs() interface{} {
	return &OAuthLoginArgs{}
}

func newOAuthLoginResult() interface{} {
	return &OAuthLoginResult{}
}

type OAuthLoginArgs struct {
	Req *user.OAuthLoginReq
}

func (p *OAuthLoginArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *OAuthLoginArgs) Unmarshal(in []byte) error {
	msg := new(user.OAuthLoginReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var OAuthLoginArgs_Req_DEFAULT *user.OAuthLoginReq

func (p *OAuthLoginArgs) GetReq() *user.OAuthLoginReq {
	if !p.IsSetReq() {
		return OAuthLoginArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *OAuthLoginArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *OAuthLoginArgs) GetFirstArgument() interface{} {
	return p.Req
}

type OAuthLoginResult struct {
	Success *user.LoginResp
}

var OAuthLoginResult_Success_DEFAULT *user.LoginResp

func (p *OAuthLoginResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *OAuthLoginResult) Unmarshal(in []byte) error {
	msg := new(user.LoginResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *OAuthLoginResult) GetSuccess() *user.LoginResp {
	if !p.IsSetSuccess() {
		return OAuthLoginResult_Success_DEFAULT
	}
	return p.Success
}

func (p *OAuthLoginResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.LoginResp)
}

func (p *OAuthLoginResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *OAuthLoginResult) GetResult() interface{} {
	return p.Success
}

func logoutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.LogoutReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).Logout(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *LogoutArgs:
		success, err := handler.(user.UserService).Logout(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*LogoutResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newLogoutArgs() interface{} {
	return &LogoutArgs{}
}

func newLogoutResult() interface{} {
	return &LogoutResult{}
}

type LogoutArgs struct {
	Req *user.LogoutReq
}

func (p *LogoutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *LogoutArgs) Unmarshal(in []byte) error {
	msg := new(user.LogoutReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var LogoutArgs_Req_DEFAULT *user.LogoutReq

func (p *LogoutArgs) GetReq() *user.LogoutReq {
	if !p.IsSetReq() {
		return LogoutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *LogoutArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *LogoutArgs) GetFirstArgument() interface{} {
	return p.Req
}

type LogoutResult struct {
	Success *user.OperationResult
}

var LogoutResult_Success_DEFAULT *user.OperationResult

func (p *LogoutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *LogoutResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *LogoutResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return LogoutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *LogoutResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *LogoutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *LogoutResult) GetResult() interface{} {
	return p.Success
}

func sessionCheckHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SessionCheckReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SessionCheck(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SessionCheckArgs:
		success, err := handler.(user.UserService).SessionCheck(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SessionCheckResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSessionCheckArgs() interface{} {
	return &SessionCheckArgs{}
}

func newSessionCheckResult() interface{} {
	return &SessionCheckResult{}
}

type SessionCheckArgs struct {
	Req *user.SessionCheckReq
}

func (p *SessionCheckArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SessionCheckArgs) Unmarshal(in []byte) error {
	msg := new(user.SessionCheckReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SessionCheckArgs_Req_DEFAULT *user.SessionCheckReq

func (p *SessionCheckArgs) GetReq() *user.SessionCheckReq {
	if !p.IsSetReq() {
		return SessionCheckArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SessionCheckArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SessionCheckArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SessionCheckResult struct {
	Success *user.SessionStatusResp
}

var SessionCheckResult_Success_DEFAULT *user.SessionStatusResp

func (p *SessionCheckResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SessionCheckResult) Unmarshal(in []byte) error {
	msg := new(user.SessionStatusResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SessionCheckResult) GetSuccess() *user.SessionStatusResp {
	if !p.IsSetSuccess() {
		return SessionCheckResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SessionCheckResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SessionStatusResp)
}

func (p *SessionCheckResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SessionCheckResult) GetResult() interface{} {
	return p.Success
}

func changePasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ChangePasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ChangePassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ChangePasswordArgs:
		success, err := handler.(user.UserService).ChangePassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ChangePasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newChangePasswordArgs() interface{} {
	return &ChangePasswordArgs{}
}

func newChangePasswordResult() interface{} {
	return &ChangePasswordResult{}
}

type ChangePasswordArgs struct {
	Req *user.ChangePasswordReq
}

func (p *ChangePasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ChangePasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ChangePasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ChangePasswordArgs_Req_DEFAULT *user.ChangePasswordReq

func (p *ChangePasswordArgs) GetReq() *user.ChangePasswordReq {
	if !p.IsSetReq() {
		return ChangePasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ChangePasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ChangePasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ChangePasswordResult struct {
	Success *user.OperationResult
}

var ChangePasswordResult_Success_DEFAULT *user.OperationResult

func (p *ChangePasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ChangePasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ChangePasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ChangePasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ChangePasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ChangePasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ChangePasswordResult) GetResult() interface{} {
	return p.Success
}

func forgotPasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ForgotPasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ForgotPassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ForgotPasswordArgs:
		success, err := handler.(user.UserService).ForgotPassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ForgotPasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newForgotPasswordArgs() interface{} {
	return &ForgotPasswordArgs{}
}

func newForgotPasswordResult() interface{} {
	return &ForgotPasswordResult{}
}

type ForgotPasswordArgs struct {
	Req *user.ForgotPasswordReq
}

func (p *ForgotPasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ForgotPasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ForgotPasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ForgotPasswordArgs_Req_DEFAULT *user.ForgotPasswordReq

func (p *ForgotPasswordArgs) GetReq() *user.ForgotPasswordReq {
	if !p.IsSetReq() {
		return ForgotPasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ForgotPasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ForgotPasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ForgotPasswordResult struct {
	Success *user.OperationResult
}

var ForgotPasswordResult_Success_DEFAULT *user.OperationResult

func (p *ForgotPasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ForgotPasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ForgotPasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ForgotPasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ForgotPasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ForgotPasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ForgotPasswordResult) GetResult() interface{} {
	return p.Success
}

func resetPasswordHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ResetPasswordReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ResetPassword(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ResetPasswordArgs:
		success, err := handler.(user.UserService).ResetPassword(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ResetPasswordResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newResetPasswordArgs() interface{} {
	return &ResetPasswordArgs{}
}

func newResetPasswordResult() interface{} {
	return &ResetPasswordResult{}
}

type ResetPasswordArgs struct {
	Req *user.ResetPasswordReq
}

func (p *ResetPasswordArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ResetPasswordArgs) Unmarshal(in []byte) error {
	msg := new(user.ResetPasswordReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ResetPasswordArgs_Req_DEFAULT *user.ResetPasswordReq

func (p *ResetPasswordArgs) GetReq() *user.ResetPasswordReq {
	if !p.IsSetReq() {
		return ResetPasswordArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ResetPasswordArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ResetPasswordArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ResetPasswordResult struct {
	Success *user.OperationResult
}

var ResetPasswordResult_Success_DEFAULT *user.OperationResult

func (p *ResetPasswordResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ResetPasswordResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ResetPasswordResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ResetPasswordResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ResetPasswordResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ResetPasswordResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ResetPasswordResult) GetResult() interface{} {
	return p.Success
}

func startBindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartBindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartBindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartBindEmailArgs:
		success, err := handler.(user.UserService).StartBindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartBindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartBindEmailArgs() interface{} {
	return &StartBindEmailArgs{}
}

func newStartBindEmailResult() interface{} {
	return &StartBindEmailResult{}
}

type StartBindEmailArgs struct {
	Req *user.StartBindEmailReq
}

func (p *StartBindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartBindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.StartBindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartBindEmailArgs_Req_DEFAULT *user.StartBindEmailReq

func (p *StartBindEmailArgs) GetReq() *user.StartBindEmailReq {
	if !p.IsSetReq() {
		return StartBindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartBindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartBindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartBindEmailResult struct {
	Success *user.OperationResult
}

var StartBindEmailResult_Success_DEFAULT *user.OperationResult

func (p *StartBindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartBindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartBindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartBindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartBindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartBindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartBindEmailResult) GetResult() interface{} {
	return p.Success
}

func completeBindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteBindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteBindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteBindEmailArgs:
		success, err := handler.(user.UserService).CompleteBindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteBindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteBindEmailArgs() interface{} {
	return &CompleteBindEmailArgs{}
}

func newCompleteBindEmailResult() interface{} {
	return &CompleteBindEmailResult{}
}

type CompleteBindEmailArgs struct {
	Req *user.CompleteBindEmailReq
}

func (p *CompleteBindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteBindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteBindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteBindEmailArgs_Req_DEFAULT *user.CompleteBindEmailReq

func (p *CompleteBindEmailArgs) GetReq() *user.CompleteBindEmailReq {
	if !p.IsSetReq() {
		return CompleteBindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteBindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteBindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteBindEmailResult struct {
	Success *user.OperationResult
}

var CompleteBindEmailResult_Success_DEFAULT *user.OperationResult

func (p *CompleteBindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteBindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteBindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteBindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteBindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteBindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteBindEmailResult) GetResult() interface{} {
	return p.Success
}

func startUnbindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartUnbindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartUnbindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartUnbindEmailArgs:
		success, err := handler.(user.UserService).StartUnbindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartUnbindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartUnbindEmailArgs() interface{} {
	return &StartUnbindEmailArgs{}
}

func newStartUnbindEmailResult() interface{} {
	return &StartUnbindEmailResult{}
}

type StartUnbindEmailArgs struct {
	Req *user.StartUnbindEmailReq
}

func (p *StartUnbindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartUnbindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.StartUnbindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartUnbindEmailArgs_Req_DEFAULT *user.StartUnbindEmailReq

func (p *StartUnbindEmailArgs) GetReq() *user.StartUnbindEmailReq {
	if !p.IsSetReq() {
		return StartUnbindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartUnbindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartUnbindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartUnbindEmailResult struct {
	Success *user.OperationResult
}

var StartUnbindEmailResult_Success_DEFAULT *user.OperationResult

func (p *StartUnbindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartUnbindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartUnbindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartUnbindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartUnbindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartUnbindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartUnbindEmailResult) GetResult() interface{} {
	return p.Success
}

func completeUnbindEmailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteUnbindEmailReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteUnbindEmail(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteUnbindEmailArgs:
		success, err := handler.(user.UserService).CompleteUnbindEmail(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteUnbindEmailResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteUnbindEmailArgs() interface{} {
	return &CompleteUnbindEmailArgs{}
}

func newCompleteUnbindEmailResult() interface{} {
	return &CompleteUnbindEmailResult{}
}

type CompleteUnbindEmailArgs struct {
	Req *user.CompleteUnbindEmailReq
}

func (p *CompleteUnbindEmailArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteUnbindEmailArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteUnbindEmailReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteUnbindEmailArgs_Req_DEFAULT *user.CompleteUnbindEmailReq

func (p *CompleteUnbindEmailArgs) GetReq() *user.CompleteUnbindEmailReq {
	if !p.IsSetReq() {
		return CompleteUnbindEmailArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteUnbindEmailArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteUnbindEmailArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteUnbindEmailResult struct {
	Success *user.OperationResult
}

var CompleteUnbindEmailResult_Success_DEFAULT *user.OperationResult

func (p *CompleteUnbindEmailResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteUnbindEmailResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteUnbindEmailResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteUnbindEmailResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteUnbindEmailResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteUnbindEmailResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteUnbindEmailResult) GetResult() interface{} {
	return p.Success
}

func startBindPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartBindPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartBindPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartBindPhoneArgs:
		success, err := handler.(user.UserService).StartBindPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartBindPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartBindPhoneArgs() interface{} {
	return &StartBindPhoneArgs{}
}

func newStartBindPhoneResult() interface{} {
	return &StartBindPhoneResult{}
}

type StartBindPhoneArgs struct {
	Req *user.StartBindPhoneReq
}

func (p *StartBindPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartBindPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.StartBindPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartBindPhoneArgs_Req_DEFAULT *user.StartBindPhoneReq

func (p *StartBindPhoneArgs) GetReq() *user.StartBindPhoneReq {
	if !p.IsSetReq() {
		return StartBindPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartBindPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartBindPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartBindPhoneResult struct {
	Success *user.OperationResult
}

var StartBindPhoneResult_Success_DEFAULT *user.OperationResult

func (p *StartBindPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartBindPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartBindPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartBindPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartBindPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartBindPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartBindPhoneResult) GetResult() interface{} {
	return p.Success
}

func completeBindPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteBindPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteBindPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteBindPhoneArgs:
		success, err := handler.(user.UserService).CompleteBindPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteBindPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteBindPhoneArgs() interface{} {
	return &CompleteBindPhoneArgs{}
}

func newCompleteBindPhoneResult() interface{} {
	return &CompleteBindPhoneResult{}
}

type CompleteBindPhoneArgs struct {
	Req *user.CompleteBindPhoneReq
}

func (p *CompleteBindPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteBindPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteBindPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteBindPhoneArgs_Req_DEFAULT *user.CompleteBindPhoneReq

func (p *CompleteBindPhoneArgs) GetReq() *user.CompleteBindPhoneReq {
	if !p.IsSetReq() {
		return CompleteBindPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteBindPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteBindPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteBindPhoneResult struct {
	Success *user.OperationResult
}

var CompleteBindPhoneResult_Success_DEFAULT *user.OperationResult

func (p *CompleteBindPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteBindPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteBindPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteBindPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteBindPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteBindPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteBindPhoneResult) GetResult() interface{} {
	return p.Success
}

func startChangePhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartChangePhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartChangePhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartChangePhoneArgs:
		success, err := handler.(user.UserService).StartChangePhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartChangePhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartChangePhoneArgs() interface{} {
	return &StartChangePhoneArgs{}
}

func newStartChangePhoneResult() interface{} {
	return &StartChangePhoneResult{}
}

type StartChangePhoneArgs struct {
	Req *user.StartChangePhoneReq
}

func (p *StartChangePhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartChangePhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.StartChangePhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartChangePhoneArgs_Req_DEFAULT *user.StartChangePhoneReq

func (p *StartChangePhoneArgs) GetReq() *user.StartChangePhoneReq {
	if !p.IsSetReq() {
		return StartChangePhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartChangePhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartChangePhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartChangePhoneResult struct {
	Success *user.OperationResult
}

var StartChangePhoneResult_Success_DEFAULT *user.OperationResult

func (p *StartChangePhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartChangePhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartChangePhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartChangePhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartChangePhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartChangePhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartChangePhoneResult) GetResult() interface{} {
	return p.Success
}

func verifyNewPhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.VerifyNewPhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).VerifyNewPhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifyNewPhoneArgs:
		success, err := handler.(user.UserService).VerifyNewPhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifyNewPhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifyNewPhoneArgs() interface{} {
	return &VerifyNewPhoneArgs{}
}

func newVerifyNewPhoneResult() interface{} {
	return &VerifyNewPhoneResult{}
}

type VerifyNewPhoneArgs struct {
	Req *user.VerifyNewPhoneReq
}

func (p *VerifyNewPhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifyNewPhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.VerifyNewPhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifyNewPhoneArgs_Req_DEFAULT *user.VerifyNewPhoneReq

func (p *VerifyNewPhoneArgs) GetReq() *user.VerifyNewPhoneReq {
	if !p.IsSetReq() {
		return VerifyNewPhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifyNewPhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifyNewPhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifyNewPhoneResult struct {
	Success *user.OperationResult
}

var VerifyNewPhoneResult_Success_DEFAULT *user.OperationResult

func (p *VerifyNewPhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifyNewPhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifyNewPhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return VerifyNewPhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifyNewPhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *VerifyNewPhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifyNewPhoneResult) GetResult() interface{} {
	return p.Success
}

func completeChangePhoneHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.CompleteChangePhoneReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).CompleteChangePhone(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *CompleteChangePhoneArgs:
		success, err := handler.(user.UserService).CompleteChangePhone(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompleteChangePhoneResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newCompleteChangePhoneArgs() interface{} {
	return &CompleteChangePhoneArgs{}
}

func newCompleteChangePhoneResult() interface{} {
	return &CompleteChangePhoneResult{}
}

type CompleteChangePhoneArgs struct {
	Req *user.CompleteChangePhoneReq
}

func (p *CompleteChangePhoneArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *CompleteChangePhoneArgs) Unmarshal(in []byte) error {
	msg := new(user.CompleteChangePhoneReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompleteChangePhoneArgs_Req_DEFAULT *user.CompleteChangePhoneReq

func (p *CompleteChangePhoneArgs) GetReq() *user.CompleteChangePhoneReq {
	if !p.IsSetReq() {
		return CompleteChangePhoneArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompleteChangePhoneArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *CompleteChangePhoneArgs) GetFirstArgument() interface{} {
	return p.Req
}

type CompleteChangePhoneResult struct {
	Success *user.OperationResult
}

var CompleteChangePhoneResult_Success_DEFAULT *user.OperationResult

func (p *CompleteChangePhoneResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *CompleteChangePhoneResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompleteChangePhoneResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return CompleteChangePhoneResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompleteChangePhoneResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *CompleteChangePhoneResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CompleteChangePhoneResult) GetResult() interface{} {
	return p.Success
}

func getUserInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.GetUserInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).GetUserInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *GetUserInfoArgs:
		success, err := handler.(user.UserService).GetUserInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetUserInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newGetUserInfoArgs() interface{} {
	return &GetUserInfoArgs{}
}

func newGetUserInfoResult() interface{} {
	return &GetUserInfoResult{}
}

type GetUserInfoArgs struct {
	Req *user.GetUserInfoReq
}

func (p *GetUserInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *GetUserInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.GetUserInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetUserInfoArgs_Req_DEFAULT *user.GetUserInfoReq

func (p *GetUserInfoArgs) GetReq() *user.GetUserInfoReq {
	if !p.IsSetReq() {
		return GetUserInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetUserInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *GetUserInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type GetUserInfoResult struct {
	Success *user.UserInfoResp
}

var GetUserInfoResult_Success_DEFAULT *user.UserInfoResp

func (p *GetUserInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *GetUserInfoResult) Unmarshal(in []byte) error {
	msg := new(user.UserInfoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetUserInfoResult) GetSuccess() *user.UserInfoResp {
	if !p.IsSetSuccess() {
		return GetUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetUserInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.UserInfoResp)
}

func (p *GetUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetUserInfoResult) GetResult() interface{} {
	return p.Success
}

func updateUserInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.UpdateUserInfoReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).UpdateUserInfo(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *UpdateUserInfoArgs:
		success, err := handler.(user.UserService).UpdateUserInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateUserInfoResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newUpdateUserInfoArgs() interface{} {
	return &UpdateUserInfoArgs{}
}

func newUpdateUserInfoResult() interface{} {
	return &UpdateUserInfoResult{}
}

type UpdateUserInfoArgs struct {
	Req *user.UpdateUserInfoReq
}

func (p *UpdateUserInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateUserInfoArgs) Unmarshal(in []byte) error {
	msg := new(user.UpdateUserInfoReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateUserInfoArgs_Req_DEFAULT *user.UpdateUserInfoReq

func (p *UpdateUserInfoArgs) GetReq() *user.UpdateUserInfoReq {
	if !p.IsSetReq() {
		return UpdateUserInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateUserInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *UpdateUserInfoArgs) GetFirstArgument() interface{} {
	return p.Req
}

type UpdateUserInfoResult struct {
	Success *user.OperationResult
}

var UpdateUserInfoResult_Success_DEFAULT *user.OperationResult

func (p *UpdateUserInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateUserInfoResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateUserInfoResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return UpdateUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateUserInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *UpdateUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UpdateUserInfoResult) GetResult() interface{} {
	return p.Success
}

func listUsersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ListUsersReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ListUsers(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ListUsersArgs:
		success, err := handler.(user.UserService).ListUsers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListUsersResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newListUsersArgs() interface{} {
	return &ListUsersArgs{}
}

func newListUsersResult() interface{} {
	return &ListUsersResult{}
}

type ListUsersArgs struct {
	Req *user.ListUsersReq
}

func (p *ListUsersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ListUsersArgs) Unmarshal(in []byte) error {
	msg := new(user.ListUsersReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListUsersArgs_Req_DEFAULT *user.ListUsersReq

func (p *ListUsersArgs) GetReq() *user.ListUsersReq {
	if !p.IsSetReq() {
		return ListUsersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListUsersArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ListUsersArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ListUsersResult struct {
	Success *user.ListUsersResp
}

var ListUsersResult_Success_DEFAULT *user.ListUsersResp

func (p *ListUsersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ListUsersResult) Unmarshal(in []byte) error {
	msg := new(user.ListUsersResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListUsersResult) GetSuccess() *user.ListUsersResp {
	if !p.IsSetSuccess() {
		return ListUsersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListUsersResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.ListUsersResp)
}

func (p *ListUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListUsersResult) GetResult() interface{} {
	return p.Success
}

func searchUserByNicknameHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SearchUserByNicknameReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SearchUserByNickname(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SearchUserByNicknameArgs:
		success, err := handler.(user.UserService).SearchUserByNickname(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SearchUserByNicknameResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSearchUserByNicknameArgs() interface{} {
	return &SearchUserByNicknameArgs{}
}

func newSearchUserByNicknameResult() interface{} {
	return &SearchUserByNicknameResult{}
}

type SearchUserByNicknameArgs struct {
	Req *user.SearchUserByNicknameReq
}

func (p *SearchUserByNicknameArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SearchUserByNicknameArgs) Unmarshal(in []byte) error {
	msg := new(user.SearchUserByNicknameReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SearchUserByNicknameArgs_Req_DEFAULT *user.SearchUserByNicknameReq

func (p *SearchUserByNicknameArgs) GetReq() *user.SearchUserByNicknameReq {
	if !p.IsSetReq() {
		return SearchUserByNicknameArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SearchUserByNicknameArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SearchUserByNicknameArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SearchUserByNicknameResult struct {
	Success *user.SearchUserByNicknameResp
}

var SearchUserByNicknameResult_Success_DEFAULT *user.SearchUserByNicknameResp

func (p *SearchUserByNicknameResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SearchUserByNicknameResult) Unmarshal(in []byte) error {
	msg := new(user.SearchUserByNicknameResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SearchUserByNicknameResult) GetSuccess() *user.SearchUserByNicknameResp {
	if !p.IsSetSuccess() {
		return SearchUserByNicknameResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SearchUserByNicknameResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.SearchUserByNicknameResp)
}

func (p *SearchUserByNicknameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SearchUserByNicknameResult) GetResult() interface{} {
	return p.Success
}

func startDeactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartDeactivateReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartDeactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartDeactivateUserArgs:
		success, err := handler.(user.UserService).StartDeactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartDeactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartDeactivateUserArgs() interface{} {
	return &StartDeactivateUserArgs{}
}

func newStartDeactivateUserResult() interface{} {
	return &StartDeactivateUserResult{}
}

type StartDeactivateUserArgs struct {
	Req *user.StartDeactivateReq
}

func (p *StartDeactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartDeactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.StartDeactivateReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartDeactivateUserArgs_Req_DEFAULT *user.StartDeactivateReq

func (p *StartDeactivateUserArgs) GetReq() *user.StartDeactivateReq {
	if !p.IsSetReq() {
		return StartDeactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartDeactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartDeactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartDeactivateUserResult struct {
	Success *user.OperationResult
}

var StartDeactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *StartDeactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartDeactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartDeactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartDeactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartDeactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartDeactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartDeactivateUserResult) GetResult() interface{} {
	return p.Success
}

func deactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.DeactivateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).DeactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeactivateUserArgs:
		success, err := handler.(user.UserService).DeactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeactivateUserArgs() interface{} {
	return &DeactivateUserArgs{}
}

func newDeactivateUserResult() interface{} {
	return &DeactivateUserResult{}
}

type DeactivateUserArgs struct {
	Req *user.DeactivateUserReq
}

func (p *DeactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.DeactivateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeactivateUserArgs_Req_DEFAULT *user.DeactivateUserReq

func (p *DeactivateUserArgs) GetReq() *user.DeactivateUserReq {
	if !p.IsSetReq() {
		return DeactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeactivateUserResult struct {
	Success *user.OperationResult
}

var DeactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *DeactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return DeactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *DeactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeactivateUserResult) GetResult() interface{} {
	return p.Success
}

func reactivateUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.ReactivateUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).ReactivateUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *ReactivateUserArgs:
		success, err := handler.(user.UserService).ReactivateUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ReactivateUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newReactivateUserArgs() interface{} {
	return &ReactivateUserArgs{}
}

func newReactivateUserResult() interface{} {
	return &ReactivateUserResult{}
}

type ReactivateUserArgs struct {
	Req *user.ReactivateUserReq
}

func (p *ReactivateUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *ReactivateUserArgs) Unmarshal(in []byte) error {
	msg := new(user.ReactivateUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ReactivateUserArgs_Req_DEFAULT *user.ReactivateUserReq

func (p *ReactivateUserArgs) GetReq() *user.ReactivateUserReq {
	if !p.IsSetReq() {
		return ReactivateUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ReactivateUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ReactivateUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type ReactivateUserResult struct {
	Success *user.OperationResult
}

var ReactivateUserResult_Success_DEFAULT *user.OperationResult

func (p *ReactivateUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *ReactivateUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ReactivateUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return ReactivateUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ReactivateUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *ReactivateUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ReactivateUserResult) GetResult() interface{} {
	return p.Success
}

func startDeleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.StartDeleteReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).StartDeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *StartDeleteUserArgs:
		success, err := handler.(user.UserService).StartDeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StartDeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newStartDeleteUserArgs() interface{} {
	return &StartDeleteUserArgs{}
}

func newStartDeleteUserResult() interface{} {
	return &StartDeleteUserResult{}
}

type StartDeleteUserArgs struct {
	Req *user.StartDeleteReq
}

func (p *StartDeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *StartDeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(user.StartDeleteReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StartDeleteUserArgs_Req_DEFAULT *user.StartDeleteReq

func (p *StartDeleteUserArgs) GetReq() *user.StartDeleteReq {
	if !p.IsSetReq() {
		return StartDeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StartDeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *StartDeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type StartDeleteUserResult struct {
	Success *user.OperationResult
}

var StartDeleteUserResult_Success_DEFAULT *user.OperationResult

func (p *StartDeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *StartDeleteUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StartDeleteUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return StartDeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StartDeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *StartDeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *StartDeleteUserResult) GetResult() interface{} {
	return p.Success
}

func deleteUserHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.DeleteUserReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).DeleteUser(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *DeleteUserArgs:
		success, err := handler.(user.UserService).DeleteUser(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteUserResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newDeleteUserArgs() interface{} {
	return &DeleteUserArgs{}
}

func newDeleteUserResult() interface{} {
	return &DeleteUserResult{}
}

type DeleteUserArgs struct {
	Req *user.DeleteUserReq
}

func (p *DeleteUserArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteUserArgs) Unmarshal(in []byte) error {
	msg := new(user.DeleteUserReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteUserArgs_Req_DEFAULT *user.DeleteUserReq

func (p *DeleteUserArgs) GetReq() *user.DeleteUserReq {
	if !p.IsSetReq() {
		return DeleteUserArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteUserArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *DeleteUserArgs) GetFirstArgument() interface{} {
	return p.Req
}

type DeleteUserResult struct {
	Success *user.OperationResult
}

var DeleteUserResult_Success_DEFAULT *user.OperationResult

func (p *DeleteUserResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteUserResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteUserResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return DeleteUserResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteUserResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *DeleteUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteUserResult) GetResult() interface{} {
	return p.Success
}

func verifySecurityCodeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.VerifyCodeReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).VerifySecurityCode(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *VerifySecurityCodeArgs:
		success, err := handler.(user.UserService).VerifySecurityCode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*VerifySecurityCodeResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newVerifySecurityCodeArgs() interface{} {
	return &VerifySecurityCodeArgs{}
}

func newVerifySecurityCodeResult() interface{} {
	return &VerifySecurityCodeResult{}
}

type VerifySecurityCodeArgs struct {
	Req *user.VerifyCodeReq
}

func (p *VerifySecurityCodeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *VerifySecurityCodeArgs) Unmarshal(in []byte) error {
	msg := new(user.VerifyCodeReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var VerifySecurityCodeArgs_Req_DEFAULT *user.VerifyCodeReq

func (p *VerifySecurityCodeArgs) GetReq() *user.VerifyCodeReq {
	if !p.IsSetReq() {
		return VerifySecurityCodeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *VerifySecurityCodeArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *VerifySecurityCodeArgs) GetFirstArgument() interface{} {
	return p.Req
}

type VerifySecurityCodeResult struct {
	Success *user.VerifyCodeResp
}

var VerifySecurityCodeResult_Success_DEFAULT *user.VerifyCodeResp

func (p *VerifySecurityCodeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *VerifySecurityCodeResult) Unmarshal(in []byte) error {
	msg := new(user.VerifyCodeResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *VerifySecurityCodeResult) GetSuccess() *user.VerifyCodeResp {
	if !p.IsSetSuccess() {
		return VerifySecurityCodeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *VerifySecurityCodeResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.VerifyCodeResp)
}

func (p *VerifySecurityCodeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *VerifySecurityCodeResult) GetResult() interface{} {
	return p.Success
}

func sendVerificationHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(user.SendVerificationReq)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(user.UserService).SendVerification(ctx, req)
		if err != nil {
			return err
		}
		return st.SendMsg(resp)
	case *SendVerificationArgs:
		success, err := handler.(user.UserService).SendVerification(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SendVerificationResult)
		realResult.Success = success
		return nil
	default:
		return errInvalidMessageType
	}
}
func newSendVerificationArgs() interface{} {
	return &SendVerificationArgs{}
}

func newSendVerificationResult() interface{} {
	return &SendVerificationResult{}
}

type SendVerificationArgs struct {
	Req *user.SendVerificationReq
}

func (p *SendVerificationArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, nil
	}
	return proto.Marshal(p.Req)
}

func (p *SendVerificationArgs) Unmarshal(in []byte) error {
	msg := new(user.SendVerificationReq)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SendVerificationArgs_Req_DEFAULT *user.SendVerificationReq

func (p *SendVerificationArgs) GetReq() *user.SendVerificationReq {
	if !p.IsSetReq() {
		return SendVerificationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SendVerificationArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *SendVerificationArgs) GetFirstArgument() interface{} {
	return p.Req
}

type SendVerificationResult struct {
	Success *user.OperationResult
}

var SendVerificationResult_Success_DEFAULT *user.OperationResult

func (p *SendVerificationResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, nil
	}
	return proto.Marshal(p.Success)
}

func (p *SendVerificationResult) Unmarshal(in []byte) error {
	msg := new(user.OperationResult)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SendVerificationResult) GetSuccess() *user.OperationResult {
	if !p.IsSetSuccess() {
		return SendVerificationResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SendVerificationResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.OperationResult)
}

func (p *SendVerificationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SendVerificationResult) GetResult() interface{} {
	return p.Success
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Register(ctx context.Context, Req *user.RegisterReq) (r *user.OperationResult, err error) {
	var _args RegisterArgs
	_args.Req = Req
	var _result RegisterResult
	if err = p.c.Call(ctx, "Register", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) EmailLogin(ctx context.Context, Req *user.EmailLoginReq) (r *user.LoginResp, err error) {
	var _args EmailLoginArgs
	_args.Req = Req
	var _result EmailLoginResult
	if err = p.c.Call(ctx, "EmailLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PhoneLogin(ctx context.Context, Req *user.PhoneLoginReq) (r *user.LoginResp, err error) {
	var _args PhoneLoginArgs
	_args.Req = Req
	var _result PhoneLoginResult
	if err = p.c.Call(ctx, "PhoneLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AccountLogin(ctx context.Context, Req *user.AccountLoginReq) (r *user.LoginResp, err error) {
	var _args AccountLoginArgs
	_args.Req = Req
	var _result AccountLoginResult
	if err = p.c.Call(ctx, "AccountLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SmsLogin(ctx context.Context, Req *user.SmsLoginReq) (r *user.SmsLoginResp, err error) {
	var _args SmsLoginArgs
	_args.Req = Req
	var _result SmsLoginResult
	if err = p.c.Call(ctx, "SmsLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) QrCodeLogin(ctx context.Context, Req *user.QrCodeLoginReq) (r *user.QrCodeLoginResp, err error) {
	var _args QrCodeLoginArgs
	_args.Req = Req
	var _result QrCodeLoginResult
	if err = p.c.Call(ctx, "QrCodeLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ConfirmQrLogin(ctx context.Context, Req *user.ConfirmQrLoginReq) (r *user.LoginResp, err error) {
	var _args ConfirmQrLoginArgs
	_args.Req = Req
	var _result ConfirmQrLoginResult
	if err = p.c.Call(ctx, "ConfirmQrLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) OAuthLogin(ctx context.Context, Req *user.OAuthLoginReq) (r *user.LoginResp, err error) {
	var _args OAuthLoginArgs
	_args.Req = Req
	var _result OAuthLoginResult
	if err = p.c.Call(ctx, "OAuthLogin", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Logout(ctx context.Context, Req *user.LogoutReq) (r *user.OperationResult, err error) {
	var _args LogoutArgs
	_args.Req = Req
	var _result LogoutResult
	if err = p.c.Call(ctx, "Logout", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SessionCheck(ctx context.Context, Req *user.SessionCheckReq) (r *user.SessionStatusResp, err error) {
	var _args SessionCheckArgs
	_args.Req = Req
	var _result SessionCheckResult
	if err = p.c.Call(ctx, "SessionCheck", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ChangePassword(ctx context.Context, Req *user.ChangePasswordReq) (r *user.OperationResult, err error) {
	var _args ChangePasswordArgs
	_args.Req = Req
	var _result ChangePasswordResult
	if err = p.c.Call(ctx, "ChangePassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ForgotPassword(ctx context.Context, Req *user.ForgotPasswordReq) (r *user.OperationResult, err error) {
	var _args ForgotPasswordArgs
	_args.Req = Req
	var _result ForgotPasswordResult
	if err = p.c.Call(ctx, "ForgotPassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ResetPassword(ctx context.Context, Req *user.ResetPasswordReq) (r *user.OperationResult, err error) {
	var _args ResetPasswordArgs
	_args.Req = Req
	var _result ResetPasswordResult
	if err = p.c.Call(ctx, "ResetPassword", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartBindEmail(ctx context.Context, Req *user.StartBindEmailReq) (r *user.OperationResult, err error) {
	var _args StartBindEmailArgs
	_args.Req = Req
	var _result StartBindEmailResult
	if err = p.c.Call(ctx, "StartBindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteBindEmail(ctx context.Context, Req *user.CompleteBindEmailReq) (r *user.OperationResult, err error) {
	var _args CompleteBindEmailArgs
	_args.Req = Req
	var _result CompleteBindEmailResult
	if err = p.c.Call(ctx, "CompleteBindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartUnbindEmail(ctx context.Context, Req *user.StartUnbindEmailReq) (r *user.OperationResult, err error) {
	var _args StartUnbindEmailArgs
	_args.Req = Req
	var _result StartUnbindEmailResult
	if err = p.c.Call(ctx, "StartUnbindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteUnbindEmail(ctx context.Context, Req *user.CompleteUnbindEmailReq) (r *user.OperationResult, err error) {
	var _args CompleteUnbindEmailArgs
	_args.Req = Req
	var _result CompleteUnbindEmailResult
	if err = p.c.Call(ctx, "CompleteUnbindEmail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartBindPhone(ctx context.Context, Req *user.StartBindPhoneReq) (r *user.OperationResult, err error) {
	var _args StartBindPhoneArgs
	_args.Req = Req
	var _result StartBindPhoneResult
	if err = p.c.Call(ctx, "StartBindPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteBindPhone(ctx context.Context, Req *user.CompleteBindPhoneReq) (r *user.OperationResult, err error) {
	var _args CompleteBindPhoneArgs
	_args.Req = Req
	var _result CompleteBindPhoneResult
	if err = p.c.Call(ctx, "CompleteBindPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartChangePhone(ctx context.Context, Req *user.StartChangePhoneReq) (r *user.OperationResult, err error) {
	var _args StartChangePhoneArgs
	_args.Req = Req
	var _result StartChangePhoneResult
	if err = p.c.Call(ctx, "StartChangePhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifyNewPhone(ctx context.Context, Req *user.VerifyNewPhoneReq) (r *user.OperationResult, err error) {
	var _args VerifyNewPhoneArgs
	_args.Req = Req
	var _result VerifyNewPhoneResult
	if err = p.c.Call(ctx, "VerifyNewPhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompleteChangePhone(ctx context.Context, Req *user.CompleteChangePhoneReq) (r *user.OperationResult, err error) {
	var _args CompleteChangePhoneArgs
	_args.Req = Req
	var _result CompleteChangePhoneResult
	if err = p.c.Call(ctx, "CompleteChangePhone", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetUserInfo(ctx context.Context, Req *user.GetUserInfoReq) (r *user.UserInfoResp, err error) {
	var _args GetUserInfoArgs
	_args.Req = Req
	var _result GetUserInfoResult
	if err = p.c.Call(ctx, "GetUserInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateUserInfo(ctx context.Context, Req *user.UpdateUserInfoReq) (r *user.OperationResult, err error) {
	var _args UpdateUserInfoArgs
	_args.Req = Req
	var _result UpdateUserInfoResult
	if err = p.c.Call(ctx, "UpdateUserInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListUsers(ctx context.Context, Req *user.ListUsersReq) (r *user.ListUsersResp, err error) {
	var _args ListUsersArgs
	_args.Req = Req
	var _result ListUsersResult
	if err = p.c.Call(ctx, "ListUsers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SearchUserByNickname(ctx context.Context, Req *user.SearchUserByNicknameReq) (r *user.SearchUserByNicknameResp, err error) {
	var _args SearchUserByNicknameArgs
	_args.Req = Req
	var _result SearchUserByNicknameResult
	if err = p.c.Call(ctx, "SearchUserByNickname", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartDeactivateUser(ctx context.Context, Req *user.StartDeactivateReq) (r *user.OperationResult, err error) {
	var _args StartDeactivateUserArgs
	_args.Req = Req
	var _result StartDeactivateUserResult
	if err = p.c.Call(ctx, "StartDeactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeactivateUser(ctx context.Context, Req *user.DeactivateUserReq) (r *user.OperationResult, err error) {
	var _args DeactivateUserArgs
	_args.Req = Req
	var _result DeactivateUserResult
	if err = p.c.Call(ctx, "DeactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ReactivateUser(ctx context.Context, Req *user.ReactivateUserReq) (r *user.OperationResult, err error) {
	var _args ReactivateUserArgs
	_args.Req = Req
	var _result ReactivateUserResult
	if err = p.c.Call(ctx, "ReactivateUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StartDeleteUser(ctx context.Context, Req *user.StartDeleteReq) (r *user.OperationResult, err error) {
	var _args StartDeleteUserArgs
	_args.Req = Req
	var _result StartDeleteUserResult
	if err = p.c.Call(ctx, "StartDeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteUser(ctx context.Context, Req *user.DeleteUserReq) (r *user.OperationResult, err error) {
	var _args DeleteUserArgs
	_args.Req = Req
	var _result DeleteUserResult
	if err = p.c.Call(ctx, "DeleteUser", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) VerifySecurityCode(ctx context.Context, Req *user.VerifyCodeReq) (r *user.VerifyCodeResp, err error) {
	var _args VerifySecurityCodeArgs
	_args.Req = Req
	var _result VerifySecurityCodeResult
	if err = p.c.Call(ctx, "VerifySecurityCode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SendVerification(ctx context.Context, Req *user.SendVerificationReq) (r *user.OperationResult, err error) {
	var _args SendVerificationArgs
	_args.Req = Req
	var _result SendVerificationResult
	if err = p.c.Call(ctx, "SendVerification", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
